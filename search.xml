<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang常见并发bug]]></title>
    <url>%2F2019%2F03%2F16%2Fgolang%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91bug%2F</url>
    <content type="text"><![CDATA[golang并发编程并发编程有两种方案：共享内存及消息传递。常见的编程语言(c/c++、java等)只提供了共享内存的方式进行变并发编程，并提供了锁、信号量等的基础操作来避免race condition带来的bug。 golang语言不仅支持了共享内存的方式，还支持消息传递的方案，并且提倡使用消息传递来共享数据。golang在语言级别内置了goroutine(一种轻量级的用户级线程)，提倡使用channel以及goroutine来进行并发编程。 因此，使用golang进行并发编程时，有两类并发bug，一种就是基于共享内存模型，这类bug(例如死锁)与用c++、java进行并发编程解决方案一样。另一种就是基于消息传递模型引发的并发bug，需要特别注意。 golang常见并发bug下面列举常见的并发bug，并分析原因，给出解决方案。谨记这些常见的错误，在以后的使用golang并发编程实战中防止再犯类似错误。 阻塞bug channel 12345678910111213141 func finishReq(timeout time.Duration) r ob &#123;2 - ch := make(chan ob)3 + ch := make(chan ob, 1)4 go func() &#123;5 result := fn()6 ch &lt;- result // block7 &#125; ()8 select &#123;9 case result = &lt;- ch:10 return result11 case &lt;- time.After(timeout):12 return nil13 &#125;14 &#125; 错误原因： finishReq函数使用匿名函数创建了一个子goroutine来处理请求，并把结果通过ch返回给父goroutine。但是如果在子goroutine中处理请求的时候超时了， 就会导致父goroutine超时返回。那么这个时候，没有其他的goroutine从ch中读取数据了，此时创建的子goroutine会一直阻塞，导致资源泄露。 解决方案： 修改的方法只需要把ch改成缓冲的channel即可 WaitGroup 1234567891 var group sync.WaitGroup2 group.Add(len(pm.plugins))3 for _, p := range pm.plugins &#123;4 go func(p *plugin) &#123;5 defer group.Done()6 &#125;7 - group.Wait()8 &#125;9 + group.Wait() 错误原因： 在使用WaitGroup的时候，需要保证Add(N)的参数N与Done调用的次数相同。在本例中，由于在循环内部调用了Wait函数，导致主goroutine会阻塞，因此不会再创建新的子goroutine。主goroutine会一直阻塞在第7行。 解决方案： 把Wait调用放在循环之外。 context 123456781 - hctx, hcancel := context.WithCancel(ctx)2 + var hctx context.Context3 + var hcancel context.CancelFunc4 if timeout &gt; 0 &#123;5 hctx, hcancel = context.WithTimeout(ctx, timeout)6 + &#125; else &#123;7 + hctx, hcancel = context.WithCancel(ctx)8 &#125; 错误原因： 在第一行代码中在创建了hctx及hcancel。根据context的惯用方式，会有其他的goroutine通过hctx.Done()来检测操作是否取消。可以通过hcancel调用来进行取消操作，从而进行并发控制。但是在后续的代码中hcancel被赋予了新的值，那么就没有其他的方式来通知等待hctx.Done()的goroutine。 解决方案： 只进行变量的定义，然后根据不同的情形进行赋值 wrong usage of channel with lock 12345678910111213141516171 func goroutine1() &#123;2 m.Lock()3 - ch &lt;- request //blocks4 + select &#123;5 + case ch &lt;- request6 + default:7 + &#125;8 m.Unlock()9 &#125;1 func goroutine2() &#123;2 for &#123;3 m.Lock() //blocks4 m.Unlock()5 request &lt;- ch6 &#125;7 &#125; 错误原因： 在goroutine1中，获取锁之后，对ch的写操作导致该goroutine会一直阻塞。然而在goroutine中，Lock操作会导致该goroutine一直阻塞。 解决方案： 在goroutine1中使用select操作，并添加default分支，避免写ch阻塞。 非阻塞bug data race caused by anonymous function 123456781 for i := 17; i &lt;= 21; i++ &#123; // write2 - go func() &#123; /* Create a new goroutine */3 + go func(i int) &#123;4 apiVersion := fmt.Sprintf("v1.%d", i) // read5 ...6 - &#125;()7 + &#125;(i)8 &#125; 错误原因： 在golang中，闭包捕获外部变量时，持有的是引用。因此appVersion的值不确定，可能去那是21。 解决方案： 使用函数参数传递变量。函数参数的传递是按值传递的，并且会复制一份。 WaitGroup 1234567891011121314151617181920211 func (p *peer) send() &#123;2 p.mu.Lock()3 defer p.mu.Unlock()4 switch p.status &#123;5 case idle:6 + p.wg.Add(1) // has to be invoked before Wait7 go func() &#123;8 - p.wg.Add(1)9 ...10 p.wg.Done()11 &#125;()12 case stopped:13 &#125;14 &#125;1 func (p * peer) stop() &#123;2 p.mu.Lock()3 p.status = stopped4 p.mu.Unlock()5 p.wg.Wait()6 &#125; 错误原因： 在使用WaitGroup时，Add函数必须在Wait之前被调用。在上述代码中，状态是idle时，可能在解锁之后，Add函数还未执行，因此并不能保证该规则。 解决方案： 把Add函数添加在受锁保护访问临界资源的代码块内。 重复关闭channel 12345671 - select &#123;2 - case &lt;- c.closed:3 - default:4 + Once.Do(func() &#123;5 close(c.closed)6 + &#125;)7 - &#125; 错误原因： 当多个goroutine执行这一块代码时，会导致c.closed管道被多次关闭，引发bug。 解决方案： 使用Once select and channel 12345678910111213141 ticker := time.NewTicker()2 for &#123;3 + select &#123;4 + case &lt;- stopCh:5 + return6 + default:7 + &#125;8 f()9 select &#123;10 case &lt;- stopCh:11 return12 case &lt;- ticker:13 &#125;14 &#125; 错误原因： select语句中如果有多个分支满足条件，那么会随机选择一个分支进行执行。在上述代码中，如果f()需要执行很长时间，那么会存在stopCh与ticker同时满足条件的情况，如果选择了ticker分支继续执行，那么就会导致f()函数会被多执行一次。 解决方案： 在f()开始之前多次判断stopCh Timer 1234567891011121 - timer := time.NewTimer(0)2 + var timeout &lt;- chan time.Time3 if dur &gt; 0 &#123;4 - timer = time.NewTimer(dur)5 + timeout = time.NewTimer(dur).C6 &#125;7 select &#123;8 - case &lt;- timer.C:9 + case &lt;- timeout:10 case &lt;-ctx.Done():11 return nil12 &#125; 出错原因： 第一行创建timer后，go运行时就开始通过internal goroutine计时。如果dur不大于0时，那么timer.C会立即满足条件，导致该函数提早结束，ctx.Done没有机会执行。 解决方案： 使用Time结构，不立即进行计时操作。只有在dur大于0时，才开始计时操作 reference[1] Tengfei Tu, Xiaoyu Liu, Linhai Song, and Yiying Zhang. 2019. Understanding Real-World Concurrency Bugs in Go . In Proceedings of 2019 Architectural Support for Programming Languages and Operating Systems (ASPLOS’19). ACM, New York, NY, USA, 14 pages. https://doi.org/http://dx.doi.org/10.1145/3297858.3304069]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>并发bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义类型：函数类型]]></title>
    <url>%2F2019%2F02%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[函数类型在golang里函数被当做first class，每当我们定义了一个新函数，就相当于定义了一种函数类型的变量。不同的函数原型可以被当做一种自定义类型使用。 1type HandlerFunc func(int, int) 既然HandlerFunc是一种类型，那么该类型有着正常类型的所有功能:比如实现接口。下面介绍一种技巧，用函数类型实现接口。 普通类型接口假设有一个map类型，在遍历该map类型的时候，我们可以传入函数，做相应的操作。 123456789type IHandler interface &#123; Do(k, v interface&#123;&#125;)&#125;func Each(m map[interface&#123;&#125;]interface&#123;&#125;, handler IHandler) &#123; for k, v := range m &#123; handler.Do(k, v) &#125;&#125; 因此，我们可以自定义一个新的类型，实现IHandler接口，从而可以处理map的元素。 1234567891011type T stringfunc (this T) Do(k, v interface&#123;&#125;) &#123; fmt.Printf("%v: %v", k, v)&#125;func main() &#123; m["test"] = 1 var t T Each(m, t)&#125; 上例子中我们定义了一个行的类型T，该类型实现了IHandler接口，因此可以作为参数传入Each函数作为参数，处理map中的元素。 然而，上述实现存在一些问题： 必须实现IHandler接口，因此必须包含Do函数。 必须定义一个新的类型，那么每当我们想要添加新的处理函数就必须得定义一个新的类型。 接口型函数(实现接口的函数类型)我们知道，函数可以作为一种类型，那么就可以实现接口。那么此时我们可以通过强制类型转换，把原型相同的函数转换成我们定义的函数类型。 12345type HandlerFunc func(k, v interface&#123;&#125;)func (h HandlerFunc) Do(k, v interface&#123;&#125;) &#123; h(k, v)&#125; HandlerFunc作为函数类型，实现了IHandler接口，因此该类型的实例变量可以作为参数传入Each函数。 12345678910111213141516171819func process(k, v interface&#123;&#125;) &#123; fmt.Printf("%v: %v", k, v)&#125;func process2(k, v interface&#123;&#125;) &#123; fmt.Printf("[%v] = %v", k, v)&#125;func main() &#123; m["test"] = 1 // 1 var f HandlerFunc f = process Each(m, f) // 2 Each(m, HandlerFunc(process2))&#125; process和process2是两个函数类型的变量，且函数原型与Do接口相同。在方法1中，声明了一个HandlerFunc类型的变量f并且赋值为process变量。在方法2中，由于golang是强类型语言，不存在隐式转换，所以需要把process2变量显示转换成HandlerFunc类型，从而可以传入Each函数。 在本例中为了突出接口型函数的用途，声明了func Each(m map[interface{}]interface{}, handler IHandler)函数，参数必须实现IHandler接口。其实完全可以声明成func Each(m map[interface{}]interface{}, handler func(k, v interface{}))那么就不存在以上问题了。只要函数原型相同的函数都可以作为参数传入Each函数。]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于redis的分布式锁实现]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%9F%BA%E4%BA%8Eredis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[redis模型Redis是基于单进程单线程模型的，即对于客户端的所有读写等请求的处理，都由一个主线程串行地处理。因此，利用该串行的性质，可以实现分布式锁。 单节点基于单个redis节点，利用redis的串行执行命令的性质，实现分布式锁。可以认为把redis作为一个数据中心来用，多个客户端共同访问。 实现锁的正确姿势获取SET resource_name my_random_value NX PX 30000 上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。 注意，在上面的SET命令中： my_random_value是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。 NX表示只有当resource_name对应的key值不存在的时候才能SET成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。 PX 30000表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。 释放使用lua脚本来释放; if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1]) else return 0 end 这段Lua脚本在执行的时候要把前面的my_random_value作为ARGV[1]的值传进去，把resource_name作为KEYS[1]的值传进去。 关键点分析 过期时间设置 获取锁必须设置过期时间。否则的话，当客户端获取锁成功后，但是客户端发生崩溃或者由于发生了网络分区，都会导致不能与redis通信，因此永远不会释放被锁住的资源。因此必须对锁设置过期时间，并且客户端必须在这个时间间隔内完成对共享资源的访问，否则就失去了锁的意义。 不能能使用setnx与expire两条指令来获取锁 有一种方案把获取锁的操作分成了两步： SETNX resource_name my_random_value EXPIRE resource_name 30 虽然这两条指令与前面描述的SET指令执行效果相同，但是由于执行的过程中不是原子的，可能发生客户端在SETNX执行成功后崩溃，那么EXPIRE没有机会执行，那么会导致一直持有该锁。 但是是否可以使用lua脚本来原子性的执行这两个操作呢？ my_random_value设置 设置my_random_value保证了一个客户端在释放锁的时候释放的是自己持有的那个锁。假设获取锁的时候设置的是一个固定的值，可能会发生一下序列： c1获取锁M成功 c1在获取锁期间执行的操作超时了(超时是指超过了锁过期时间，比如阻塞操作) 锁自动释放 c2获取了同一个锁M 在c2获取锁的期间，c1恢复操作，此时执行锁释放操作，那么如果设置的是固定值，那么c1会释放掉c2持有的锁。之后c2访问共享资源时，就没有锁提供保护。 使用lua脚本释放锁 在redis中执行lua脚本能保证操作的原子性。释放锁其实包含三步操作：GET、判断和DEL，用Lua脚本来实现能保证这三步的原子性。如果把这三个步骤放到客户端中分开执行的话，就可能发生与上面类似的执行序列： c1获取锁M成功 c1访问共享资源，并释放锁 c1释放锁，首先执行GET操作，但是由于某些原因(网络延迟，客户端得到GET结果延迟)，导致c1在执行DEL操作前已经超时。 过期时间到，锁自动释放。 c2获取同一个锁M 在c2获取锁的期间，c1执行DEL操作，c1释放掉c2持有的锁。之后c2访问共享资源时，就没有锁提供保护。 问题 单点故障 前面的注意点保证了分布式锁的正确性，但是由于是基于单节点实现分布式锁，所以如果该节点出现了故障，那么就会整个服务不可用。 redis提供了主从备份的机制，但是使用该机制也不能解决单点分布式锁面临的单点故障问题。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。考虑下面的执行序列： c1从Master获取了锁。 Master宕机了，存储锁的key还没有来得及同步到Slave上。 Slave升级为Master。 c2从新的Master获取到了对应同一个资源的锁。 于是，c1和c2同时持有了同一个资源的锁。锁的安全性被打破。 过期时间设置 这个分布式锁的算法，需要设置锁的有效时间，那么设置多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。是个两难的问题。 多节点Redlock为了解决基于单点redis实现分布式锁服务存在的单点故障问题，redis作者antirez设计了Redlock算法。这个算法基于多个redis节点。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash-guide]]></title>
    <url>%2F2018%2F02%2F23%2Fbash-guide%2F</url>
    <content type="text"><![CDATA[Table of Contents Basic Operations1.1. File Operations1.2. Text Operations1.3. Directory Operations1.4. SSH, System Info &amp; Network Operations1.5. Process Monitoring Operations Basic Shell Programming2.1. Variables2.2. Array2.3. String Substitution2.4. Functions2.5. Conditionals2.6. Loops Tricks Debugging 1. Basic Operationsa. exportDisplays all environment variables. If you want to get details of a specific variable, use echo $VARIABLE_NAME.1export Example:12345678$ exportAWS_HOME=/Users/adnanadnan/.awsLANG=en_US.UTF-8LC_CTYPE=en_US.UTF-8LESS=-R$ echo $AWS_HOME/Users/adnanadnan/.aws b. whatiswhatis shows description for user commands, system calls, library functions, and others in manual pages1whatis something Example:12$ whatis bashbash (1) - GNU Bourne-Again SHell c. whereiswhereis searches for executables, source files, and manual pages using a database built by system automatically.1whereis name Example:12$ whereis php/usr/bin/php d. whichwhich searches for executables in the directories specified by the environment variable PATH. This command will print the full path of the executable(s).1which program_name Example:12$ which php/c/xampp/php/php e. clearClears content on window. 1.1. File Operations cat chmod chown cp diff file find gunzip gzcat gzip head lpq lpr lprm ls more mv rm tail touch a. catIt can be used for the following purposes under UNIX or Linux. Display text files on screen Copy text files Combine text files Create new text files 1234cat filenamecat file1 file2 cat file1 file2 &gt; newcombinedfilecat &lt; file1 &gt; file2 #copy file1 to file2 b. chmodThe chmod command stands for “change mode” and allows you to change the read, write, and execute permissions on your files and folders. For more information on this command check this link.1chmod -options filename c. chownThe chown command stands for “change owner”, and allows you to change the owner of a given file or folder, which can be a user and a group. Basic usage is simple forward first comes the user (owner), and then the group, delimited by a colon.1chown -options user:group filename d. cpCopies a file from one location to other.1cp filename1 filename2 Where filename1 is the source path to the file and filename2 is the destination path to the file. e. diffCompares files, and lists their differences.1diff filename1 filename2 f. fileDetermine file type.1file filename Example:12$ file index.html index.html: HTML document, ASCII text g. findFind files in directory1find directory options pattern Example:12$ find . -name README.md$ find /home/user1 -name '*.png' h. gunzipUn-compresses files compressed by gzip.1gunzip filename i. gzcatLets you look at gzipped file without actually having to gunzip it.1gzcat filename j. gzipCompresses files.1gzip filename k. headOutputs the first 10 lines of file1head filename l. lpqCheck out the printer queue.1lpq Example:1234$ lpqRank Owner Job File(s) Total Sizeactive adnanad 59 demo 399360 bytes1st adnanad 60 (stdin) 0 bytes m. lprPrint the file.1lpr filename n. lprmRemove something from the printer queue.1lprm jobnumber o. lsLists your files. ls has many options: -l lists files in ‘long format’, which contains the exact size of the file, who owns the file, who has the right to look at it, and when it was last modified. -a lists all files, including hidden files. For more information on this command check this link.1ls option Example: $ ls -la rwxr-xr-x 33 adnan staff 1122 Mar 27 18:44 . drwxrwxrwx 60 adnan staff 2040 Mar 21 15:06 .. -rw-r--r--@ 1 adnan staff 14340 Mar 23 15:05 .DS_Store -rw-r--r-- 1 adnan staff 157 Mar 25 18:08 .bumpversion.cfg -rw-r--r-- 1 adnan staff 6515 Mar 25 18:08 .config.ini -rw-r--r-- 1 adnan staff 5805 Mar 27 18:44 .config.override.ini drwxr-xr-x 17 adnan staff 578 Mar 27 23:36 .git -rwxr-xr-x 1 adnan staff 2702 Mar 25 18:08 .gitignore p. moreShows the first part of a file (move with space and type q to quit).1more filename q. mvMoves a file from one location to other.1mv filename1 filename2 Where filename1 is the source path to the file and filename2 is the destination path to the file. Also it can be used for rename a file.1mv old_name new_name r. rmRemoves a file. Using this command on a directory gives you an error.rm: directory: is a directoryTo remove a directory you have to pass -r which will remove the content of the directory recursively. Optionally you can use -f flag to force the deletion i.e. without any confirmations etc.1rm filename s. tailOutputs the last 10 lines of file. Use -f to output appended data as the file grows.1tail filename t. touchUpdates access and modification time stamps of your file. If it doesn’t exists, it’ll be created.1touch filename Example:1$ touch trick.md 1.2. Text Operations awk cut echo egrep fgrep fmt grep nl sed sort tr uniq wc a. awkawk is the most useful command for handling text files. It operates on an entire file line by line. By default it uses whitespace to separate the fields. The most common syntax for awk command is 1awk '/search_pattern/ &#123; action_to_take_if_pattern_matches; &#125;' file_to_parse Lets take following file /etc/passwd. Here’s the sample data that this file contains:12345root:x:0:0:root:/root:/usr/bin/zshdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/sync So now lets get only username from this file. Where -F specifies that on which base we are going to separate the fields. In our case it’s :. { print $1 } means print out the first matching field.1awk -F':' '&#123; print $1 &#125;' /etc/passwd After running the above command you will get following output.12345rootdaemonbinsyssync For more detail on how to use awk, check following link. b. cutRemove sections from each line of files example.txt1red riding hood went to the park to play show me columns 2 , 7 , and 9 with a space as a separator1cut -d " " -f2,7,9 example.txt 1riding park play c. echoDisplay a line of text display “Hello World”1echo Hello World 1Hello World display “Hello World” with newlines between words1echo -ne "Hello\nWorld\n" 12HelloWorld d. egrepPrint lines matching a pattern - Extended Expression (alias for: ‘grep -E’) example.txt12345678910111213141516171819Lorem ipsumdolor sit amet, consetetursadipscing elitr,sed diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, seddiam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet. display lines that have either “Lorem” or “dolor” in them.123egrep '(Lorem|dolor)' example.txtorgrep -E '(Lorem|dolor)' example.txt 123456Lorem ipsumdolor sit amet,et dolore magnaduo dolores et easanctus est Loremipsum dolor sit e. fgrepPrint lines matching a pattern - FIXED pattern matching (alias for: ‘grep -F’) example.txt1234567891011121314151617181920Lorem ipsumdolor sit amet,consetetursadipscing elitr,sed diam nonumyeirmod temporfoo (Lorem|dolor) invidunt ut laboreet dolore magnaaliquyam erat, seddiam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet. Find the exact string ‘(Lorem|dolor)’ in example.txt123fgrep '(Lorem|dolor)' example.txtorgrep -F '(Lorem|dolor)' example.txt 1foo (Lorem|dolor) f. fmtSimple optimal text formatter example: example.txt (1 line)1Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. output the lines of example.txt to 20 character width1cat example.txt | fmt -w 20 12345678910111213141516171819Lorem ipsumdolor sit amet,consetetursadipscing elitr,sed diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, seddiam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet. g. grepLooks for text inside files. You can use grep to search for lines of text that match one or many regular expressions, and outputs only the matching lines.1grep pattern filename Example:1234$ grep admin /etc/passwd_kadmin_admin:*:218:-2:Kerberos Admin Service:/var/empty:/usr/bin/false_kadmin_changepw:*:219:-2:Kerberos Change Password Service:/var/empty:/usr/bin/false_krb_kadmin:*:231:-2:Open Directory Kerberos Admin Service:/var/empty:/usr/bin/false You can also force grep to ignore word case by using -i option. -r can be used to search all files under the specified directory, for example:1$ grep -r admin /etc/ And -w to search for words only. For more detail on grep, check following link. h. nlNumber lines of files example.txt12345678910111213141516171819Lorem ipsumdolor sit amet,consetetursadipscing elitr,sed diam nonumyeirmod temporinvidunt ut laboreet dolore magnaaliquyam erat, seddiam voluptua. Atvero eos etaccusam et justoduo dolores et earebum. Stet clitakasd gubergren,no sea takimatasanctus est Loremipsum dolor sitamet. show example.txt with line numbers1nl -s". " example.txt 12345678910111213141516171819 1. Lorem ipsum 2. dolor sit amet, 3. consetetur 4. sadipscing elitr, 5. sed diam nonumy 6. eirmod tempor 7. invidunt ut labore 8. et dolore magna 9. aliquyam erat, sed10. diam voluptua. At11. vero eos et12. accusam et justo13. duo dolores et ea14. rebum. Stet clita15. kasd gubergren,16. no sea takimata17. sanctus est Lorem18. ipsum dolor sit19. amet. i. sedStream editor for filtering and transforming text example.txt123456Hello This is a Test 1 2 3 4``` *replace all spaces with hyphens*```bashsed 's/ /-/g' example.txt 1Hello-This-is-a-Test-1-2-3-4 replace all digits with “d”1sed 's/[0-9]/d/g' example.txt 1Hello This is a Test d d d d j. sortSort lines of text files example.txt1234567fbcgaed sort example.txt1sort example.txt 1234567abcdefg randomize a sorted example.txt1sort example.txt | sort -R 1234567bfacdge k. trTranslate or delete characters example.txt1Hello World Foo Bar Baz! take all lower case letters and make them upper case1cat example.txt | tr 'a-z' 'A-Z' 1HELLO WORLD FOO BAR BAZ! take all spaces and make them into newlines1cat example.txt | tr ' ' '\n' 12345HelloWorldFooBarBaz! l. uniqReport or omit repeated lines example.txt12345678aababcdc show only unique lines of example.txt (first you need to sort it, otherwise it won’t see the overlap)1sort example.txt | uniq 1234abcd show the unique items for each line, and tell me how many instances it found1sort example.txt | uniq -c 12343 a2 b2 c1 d m. wcTells you how many lines, words and characters there are in a file.1wc filename Example:12$ wc demo.txt7459 15915 398400 demo.txt Where 7459 is lines, 15915 is words and 398400 is characters. 1.3. Directory Operations cd mkdir pwd a. cdMoves you from one directory to other. Running this1$ cd moves you to home directory. This command accepts an optional dirname, which moves you to that directory.1cd dirname b. mkdirMakes a new directory.1mkdir dirname c. pwdTells you which directory you currently are in.1pwd 1.4. SSH, System Info &amp; Network Operations bg cal date df dig du fg finger jobs last man passwd ping ps quota scp ssh top uname uptime w wget whoami whois a. bgLists stopped or background jobs; resume a stopped job in the background. b. calShows the month’s calendar. c. dateShows the current date and time. d. dfShows disk usage. e. digGets DNS information for domain.1dig domain f. duShows the disk usage of files or directories. For more information on this command check this link1du [option] [filename|directory] Options: -h (human readable) Displays output it in kilobytes (K), megabytes (M) and gigabytes (G). -s (supress or summarize) Outputs total disk space of a directory and supresses reports for subdirectories. Example:12du -sh pictures1.4M pictures g. fgBrings the most recent job in the foreground. h. fingerDisplays information about user.1finger username i. jobsLists the jobs running in the background, giving the job number. j. lastLists your last logins of specified user.1last yourUsername k. manShows the manual for specified command.1man command l. passwdAllows the current logged user to change their password. m. pingPings host and outputs results.1ping host n. psLists your processes.1ps -u yourusername Use the flags ef. e for every process and f for full listing.1ps -ef o. quotaShows what your disk quota is.1quota -v p. scpTransfer files between a local host and a remote host or between two remote hosts. copy from local host to remote host1scp source_file user@host:directory/target_file copy from remote host to local host12scp user@host:directory/source_file target_filescp -r user@host:directory/source_folder target_folder This command also accepts an option -P that can be used to connect to specific port.1scp -P port user@host:directory/source_file target_file q. sshssh (SSH client) is a program for logging into and executing commands on a remote machine.1ssh user@host This command also accepts an option -p that can be used to connect to specific port.1ssh -p port user@host r. topDisplays your currently active processes. s. unameShows kernel information.1uname -a t. uptimeShows current uptime. u. wDisplays who is online. v. wgetDownloads file.1wget file w. whoamiReturn current logged in username. x. whoisGets whois information for domain.1whois domain 1.5. Process Monitoring Operations kill killall &amp; nohup a. killKills (ends) the processes with the ID you gave.1kill PID b. killallKill all processes with the name.1killall processname c. &amp;The &amp; symbol instructs the command to run as a background process in a subshell.1command &amp; d. nohupnohup stands for “No Hang Up”. This allows to run command/process or shell script that can continue running in the background after you log out from a shell.1nohup command Combine it with &amp; to create background processes1nohup command &amp; 2. Basic Shell ProgrammingThe first line that you will write in bash script files is called shebang. This line in any script determines the script’s ability to be executed like a standalone executable without typing sh, bash, python, php etc beforehand in the terminal. 1#!/usr/bin/env bash 2.1. VariablesCreating variables in bash is similar to other languages. There are no data types. A variable in bash can contain a number, a character, a string of characters, etc. You have no need to declare a variable, just assigning a value to its reference will create it. Example:1str="hello world" The above line creates a variable str and assigns “hello world” to it. The value of variable is retrieved by putting the $ in the beginning of variable name. Example:1echo $str # hello world 2.2. ArrayLike other languages bash has also arrays. An array is variable containing multiple values. There’s no maximum limit on the size of array. Array in bash are zero based. The first element is indexed with element 0. There are several ways for creating arrays in bash. Which are given below. Examples:12345array[0] = valarray[1] = valarray[2] = valarray=([2]=val [0]=val [1]=val)array=(val val val) To display a value at specific index use following syntax: 1$&#123;array[i]&#125; # where i is the index If no index is supplied, array element 0 is assumed. To find out how many values there are in the array use the following syntax: 1$&#123;#array[@]&#125; Bash has also support for the ternary conditions. Check some examples below. 1234$&#123;varname:-word&#125; # if varname exists and isn't null, return its value; otherwise return word$&#123;varname:=word&#125; # if varname exists and isn't null, return its value; otherwise set it word and then return its value$&#123;varname:+word&#125; # if varname exists and isn't null, return word; otherwise return null$&#123;varname:offset:length&#125; # performs substring expansion. It returns the substring of $varname starting at offset and up to length characters 2.3 String SubstitutionCheck some of the syntax on how to manipulate strings 1234567$&#123;variable#pattern&#125; # if the pattern matches the beginning of the variable's value, delete the shortest part that matches and return the rest$&#123;variable##pattern&#125; # if the pattern matches the beginning of the variable's value, delete the longest part that matches and return the rest$&#123;variable%pattern&#125; # if the pattern matches the end of the variable's value, delete the shortest part that matches and return the rest$&#123;variable%%pattern&#125; # if the pattern matches the end of the variable's value, delete the longest part that matches and return the rest$&#123;variable/pattern/string&#125; # the longest match to pattern in variable is replaced by string. Only the first match is replaced$&#123;variable//pattern/string&#125; # the longest match to pattern in variable is replaced by string. All matches are replaced$&#123;#varname&#125; # returns the length of the value of the variable as a character string 2.4. FunctionsAs in almost any programming language, you can use functions to group pieces of code in a more logical way or practice the divine art of recursion. Declaring a function is just a matter of writing function my_func { my_code }. Calling a function is just like calling another program, you just write its name. 123function name() &#123; shell commands&#125; Example:12345678910#!/bin/bashfunction hello &#123; echo world!&#125;hellofunction say &#123; echo $1&#125;say "hello world!" When you run the above example the hello function will output “world!”. The above two functions hello and say are identical. The main difference is function say. This function, prints the first argument it receives. Arguments, within functions, are treated in the same manner as arguments given to the script. 2.5. ConditionalsThe conditional statement in bash is similar to other programming languages. Conditions have many form like the most basic form is if expression then statement where statement is only executed if expression is true. 12345if [ expression ]; then will execute only if expression is trueelse will execute if expression is falsefi Sometime if conditions becoming confusing so you can write the same condition using the case statements. 1234567case expression in pattern1 ) statements ;; pattern2 ) statements ;; ...esac Expression Examples: 12345678910111213141516171819202122232425262728293031statement1 &amp;&amp; statement2 # both statements are truestatement1 || statement2 # at least one of the statements is truestr1=str2 # str1 matches str2str1!=str2 # str1 does not match str2str1&lt;str2 # str1 is less than str2str1&gt;str2 # str1 is greater than str2-n str1 # str1 is not null (has length greater than 0)-z str1 # str1 is null (has length 0)-a file # file exists-d file # file exists and is a directory-e file # file exists; same -a-f file # file exists and is a regular file (i.e., not a directory or other special type of file)-r file # you have read permission-s file # file exists and is not empty-w file # you have write permission-x file # you have execute permission on file, or directory search permission if it is a directory-N file # file was modified since it was last read-O file # you own file-G file # file's group ID matches yours (or one of yours, if you are in multiple groups)file1 -nt file2 # file1 is newer than file2file1 -ot file2 # file1 is older than file2-lt # less than-le # less than or equal-eq # equal-ge # greater than or equal-gt # greater than-ne # not equal 2.6. LoopsThere are three types of loops in bash. for, while and until. Different for Syntax:1234567891011121314for x := 1 to 10 dobegin statementsendfor name [in list]do statements that can use $namedonefor (( initialisation ; ending condition ; update ))do statements...done while Syntax:123while condition; do statementsdone until Syntax:123until condition; do statementsdone 3. TricksSet an aliasOpen bash_profile by running following command nano ~/.bash_profile alias dockerlogin=’ssh www-data@adnan.local -p2222’ # add your alias in .bash_profile To quickly go to a specific directorynano ~/.bashrc export hotellogs=”/workspace/hotel-api/storage/logs” 12source ~/.bashrccd $hotellogs Exit trapsMake your bash scripts more robust by reliably performing cleanup. 12345function finish &#123; # your cleanup here. e.g. kill any forked processes jobs -p | xargs kill&#125;trap finish EXIT Saving your environment variablesWhen you do export FOO = BAR, your variable is only exported in this current shell and all its children, to persist in the future you can simply append in your ~/.bash_profile file the command to export your variable1echo export FOO=BAR &gt;&gt; ~/.bash_profile Accessing your scriptsYou can easily access your scripts by creating a bin folder in your home with mkdir ~/bin, now all the scripts you put in this folder you can access in any directory. If you can not access, try append the code below in your ~/.bash_profile file and after do source ~/.bash_profile.1234# set PATH so it includes user's private bin if it existsif [ -d "$HOME/bin" ] ; then PATH="$HOME/bin:$PATH"fi 4. DebuggingYou can easily debug the bash script by passing different options to bash command. For example -n will not run commands and check for syntax errors only. -v echo commands before running them. -x echo commands after command-line processing. 123bash -n scriptnamebash -v scriptnamebash -x scriptname Contribution Report issues How to Open pull request with improvements How to Spread the word Translation Chinese | 简体中文 Turkish | Türkçe Japanese | 日本語 License]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说MVC，MVP和MVVM]]></title>
    <url>%2F2018%2F02%2F07%2F%E8%AF%B4%E8%AF%B4MVC%EF%BC%8CMVP%E5%92%8CMVVM%2F</url>
    <content type="text"><![CDATA[前言做客户端开发、前端开发对MVC、MVP、MVVM这些名词不了解也应该大致听过，都是为了解决图形界面应用程序复杂性管理问题而产生的应用架构模式。 网上很多文章关于这方面的讨论比较杂乱，各种 MV 模式之间的区别分不清，甚至有些描述都是错误的。本文追根溯源，从最经典的Smalltalk-80 MVC模式开始逐步还原图形界面之下最真实的 MV 模式。 GUI程序面临的问题图形界面的应用程序提供给用户可视化的操作界面，这个界面提供给数据和信息。用户输入行为（键盘，鼠标等）会执行一些业务逻辑，可能会导致对应用程序数据的变更，数据的变更自然需要用户界面的同步变更以提供最准确的信息。例如用户对一个电子表格重新排序的操作，应用程序需要响应用户操作，对数据进行排序，然后需要同步到界面上。 在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离（Speration of Duties）的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会把管理用户界面的层次称为View，应用程序的数据为Model（注意这里的Model指的是Domain Model，这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以简单理解为对象）。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口 有了View和Model的分层，那么就有了两个问题： 响应用户操作的业务逻辑（例如排序）的管理。 View如何同步Model的变更。 带着这两个问题开始探索 MV 模式，会发现这些模式之间的差异可以归纳为对这两个问题处理的方式的不同。而几乎所有的 MV 模式都是经典的Smalltalk-80 MVC的修改版。 Smalltalk-80 MVC历史背景早在上个世纪70年代，美国的施乐公司（Xerox）的工程师研发了Smalltalk编程语言，并且开始用它编写图形界面的应用程序。而在Smalltalk-80这个版本的时候，一位叫Trygve Reenskaug的工程师设计了MVC图形应用程序的架构模式，极大地降低了图形应用程序的管理难度。而在四人众（GoF）的设计模式当中并没有把MVC当做是设计模式，而仅仅是把它看成解决问题的一些类的集合。Smalltalk-80 MVC和GoF描述的MVC是最经典的MVC模式。 MVC的依赖关系MVC除了把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。Model、View、Controller三个层次的依赖关系如下： Controller和View都依赖Model层，Controller和View可以互相依赖。在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的业务逻辑的处理权交给Controller。 MVC的调用关系用户的对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller（Pass calls）；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View；View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。如下图： 看似没有什么特别的地方，但是由几个需要特别关注的关键点： View是把控制权交移给Controller，自己不执行业务逻辑。 Controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。 View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。 需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很多对于MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同的MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接受到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。我们每天都在用的观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。 这里有一个MVC模式的JavaScript Demo，实现了一个小的TodoList应用程序。经典的Smalltalk-80 MVC不需要任何框架支持就可以实现。目前Web前端框架当中只有一个号称是严格遵循Smalltalk-80 MVC模式的：maria.js。 MVC的优缺点优点： 把业务逻辑全部分离到Controller中，模块化程度高。当业务逻辑变更的时候，不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）。 观察者模式可以做到多视图同时更新。 缺点： Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候，无法对View的更新操作进行断言。 View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的 MVC Model 2在Web服务端开发的时候也会接触到MVC模式，而这种MVC模式不能严格称为MVC模式。经典的MVC模式只是解决客户端图形界面应用程序的问题，而对服务端无效。服务端的MVC模式又自己特定的名字：MVC Model 2，或者叫JSP Model 2，或者直接就是Model 2 。Model 2客户端服务端的交互模式如下： 服务端接收到来自客户端的请求，服务端通过路由规则把这个请求交由给特定的Controller进行处理，Controller执行相应的业务逻辑，对数据库数据（Model）进行操作，然后用数据去渲染特定的模版，返回给客户端。 因为HTTP协议是单工协议并且是无状态的，服务器无法直接给客户端推送数据。除非客户端再次发起请求，否则服务器端的Model的变更就无法告知客户端。所以可以看到经典的Smalltalk-80 MVC中Model通过观察者模式告知View更新这一环被无情地打破，不能称为严格的MVC。 Model 2模式最早在1998年应用在JSP应用程序当中，JSP Model 1应用管理的混乱诱发了JSP参考了客户端MVC模式，催生了Model 2。 后来这种模式几乎被应用在所有语言的Web开发框架当中。PHP的ThinkPHP，Python的Dijango、Flask，NodeJS的Express，Ruby的RoR，基本都采纳了这种模式。平常所讲的MVC基本是这种服务端的MVC。 MVPMVP模式有两种： Passive View Supervising Controller 而大多数情况下讨论的都是Passive View模式。本文会对PV模式进行较为详细的介绍，而SC模式则简单提及。 历史背景MVP模式是MVC模式的改良。在上个世纪90年代，IBM旗下的子公司Taligent在用C/C++开发一个叫CommonPoint的图形界面应用系统的时候提出来的。 MVP（Passive View）的依赖关系MVP模式把MVC模式中的Controller换成了Presenter。MVP层次之间的依赖关系如下： MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。 MVP（Passive View）的调用关系既然View对Model的依赖被打破了，那View如何同步Model的变更？看看MVP的调用关系： 和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑，并且对Model进行相应的操作；而这时候Model也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。 关键点： View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。 View需要提供操作界面的接口给Presenter进行调用。（关键） 对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。 MVP模式，这里也提供一个用JavaScript编写的例子。 MVP（Passive View）的优缺点优点： 便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性。这里根据上面的例子给出了Presenter的单元测试样例。 View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做高度可复用的View组件。 缺点： Presenter中除了业务逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 MVP（Supervising Controller）上面讲的是MVP的Passive View模式，该模式下View非常Passive，它几乎什么都不知道，Presenter让它干什么它就干什么。而Supervising Controller模式中，Presenter会把一部分简单的同步逻辑交给View自己去做，Presenter只负责比较复杂的、高层次的UI操作，所以可以把它看成一个Supervising Controller。 Supervising Controller模式下的依赖和调用关系： 因为Supervising Controller用得比较少，对它的讨论就到这里为止。 MVVMMVVM可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。 历史背景MVVM模式最早是微软公司提出，并且了大量使用在.NET的WPF和Sliverlight中。2005年微软工程师John Gossman在自己的博客上首次公布了MVVM模式。 ViewModelMVVM代表的是Model-View-ViewModel，这里需要解释一下什么是ViewModel。ViewModel的含义就是 “Model of View”，视图的模型。它的含义包含了领域模型（Domain Model）和视图的状态（State）。 在图形界面应用程序当中，界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态是顺序的还是逆序的，而这是Domain Model所不包含的，但也是需要显示的信息。 可以简单把ViewModel理解为页面上所显示内容的数据抽象，和Domain Model不一样，ViewModel更适合用来描述View。 MVVM的依赖MVVM的依赖关系和MVP依赖，只不过是把P换成了VM。 MVVM的调用关系MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder，或者是Data-binding engine的东西。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模版引擎，但是会根据数据变更实时渲染。 也就是说，MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。 这里有一个JavaScript MVVM的例子，因为MVVM需要Binder引擎。所以例子中使用了一个MVVM的库：Vue.js。 MVVM的优缺点优点： 提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。 简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。 缺点： 过于简单的图形界面不适用，或说牛刀杀鸡。 对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。 数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。 结语可以看到，从MVC-&gt;MVP-&gt;MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。同样的Demo功能，代码从最开始的一堆文件，优化成了最后只需要20几行代码就完成。MV*模式之间的区分还是蛮清晰的，希望可以给对这些模式理解比较模糊的同学带来一些参考和思路。 referenceScaling Isomorphic Javascript Code Smalltalk-80 MVC Learning JavaScript Design Patterns Smalltalk-80 MVC in JavaScript GUI Architectures The Model-View-Presenter (MVP) Pattern 转摘：http://www.linuxidc.com/Linux/2015-10/124622.htm]]></content>
      <categories>
        <category>architecture</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宏定义黑魔法-从入门到奇技淫巧]]></title>
    <url>%2F2018%2F01%2F25%2F%E5%AE%8F%E5%AE%9A%E4%B9%89%E9%BB%91%E9%AD%94%E6%B3%95-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[基础概念楔子最近在研究如何在 C++ 里边实现反射，结果发现了很多有意思的技巧。可惜其中相当一部分都是依赖于宏实现的，晦涩难懂。这个过程中断断续续查了很多资料，发现网上不管是中文还是英文都很少有资料对宏的用法有一个比较完整的介绍。特别是一些「奇技淫巧」类的惯用法。少数几个也没有原理上的分析，十分可惜。所以在这里将自己搜集到的东西整理成一个教程，以飨列位。随着教程的深入，你会发现宏的能力远超一般的认识。利用各种猥琐的技巧，可以使宏具有接近图灵完备语言的能力。 一般来说在 C++ 中是不提倡使用宏的，模板已经能够很好地替代宏的绝大多数功能了。宏由于其自身设计的原因，使用起来不仅晦涩难懂，而且还有很多难以预料的坑。那么现在是不是就没有学习宏的必要了呢？笔者认为答案是否定的。理由有三：其一，仍有一小部分功能模板无法替代宏来实现，且有的功能使用宏比模板更加的直观。其二，以前的遗留代码中有大量的宏，而这些库在今天依旧有着广泛的应用。其三，宏的很多惯用发思路清奇又猥琐，却又暗合编程语言理论，用来把玩也是很有趣的。 宏的定义绝大多数人对于宏的概念仅仅停留在简单替换的程度上，例如： 1234#define N 42N// -&gt;42 众所周知，这个宏的作用是找到源文件中所有的 N 然后将其替换为 42。然而，对于 C 和 C++ 的预处理需求来说，这种功能过于简单了。有时候我们希望能够根据不同的参数来进行某种模式的替换。这就产生了第二种宏，带参数的宏。例如： 1234// obj-like#define 宏名 替换列表 换行符//func-like#define 宏名 ([标识符列表]) 替换列表 换行符 其中替换列表和标识符列表都是将字符串 token (如果对 token 这个概念比较陌生请看文章最后) 化以后的列表。区别在于标识符列表使用,作为不同参数之间的分割符。每一个参数都是一个 token 化的列表。 这里有两点值得注意的地方：1. 宏的内容会被 token 化成一个替换列表。也就是说，预处理器在处理宏展开时并不是以字符串的形式处理，而是以 token 列表的形式处理的。这对于我们理解宏的行为非常重要。例如，在宏中空白符只起到分割 token 的作用，空白符的多少对于预处理器是没有意义的： 12345#define MAIN \int main() \&#123; \ return 0; \&#125; 此外，宏可以重复定义，但前提是两次定义的内容完全一致。例如： 123456// 合法的二次定义#define FOO int foo;#define FOO int foo;//重定义错误，有的编译器会给出警告并使用最后一次的宏定义#define FOO int* foo;#define FOO int foo; 宏的操作符和 C, C++ 语言本体不同，宏有着它自己特有的两个操作符。下边简单地介绍一下。 字符串化操作符 #有时候我们希望能够讲参数转换为字符串进行处理，# 可以将一个 token 字符串化。例如： 12345678#define WARN_IF(EXP) \ if (EXP) \ &#123;\ fprintf (stderr, "Warning: " #EXP "\n"); \ &#125;\WARN_IF (x/* const char* */ == "0")// -&gt;if (x == "0") &#123; fprintf (stderr, "Warning: " "x == \"0\"" "\n"); &#125; 此处有几点需要注意： #操作符并不是简单的添加双引号，它会自动对特殊字符进行转义。 #操作符只能对 func-like 的参数使用。 由于参数会转化为 token 列表，所以前后的空白符都会被忽略，中间的空白符会被压缩为一个，注释会被忽略并变成一个空白符。 Token 粘贴操作符然后我们再学习一个新的操作符 ##，## 可以将两个 token 合并为一个。合并新的 token 有什么用呢？它可以提供给你动态的生成 token 的能力，例如： 1234#define GETTER(x, T) T get_ ## x() &#123;return this-&gt;x;&#125;GETTER(foo， const int)//-&gt;const int get_foo() &#123;return this-&gt;foo;&#125; 此处通过GETTER生成了一个对于属性x的访问器。当然，这并不是一个明智的做法，而且还有很多漏洞。但是它展示给了我们宏动态生成 token 的能力。 有人可能注意第一个x需要##来进行连接，第二个却不需要。这是因为预处理器以 token 列表的方式处理展开过程。对于第一个x如果不使用##，那么对于预处理器来说get_x只是一个内容为getx的 token，x 并不会被替换。若需要将 x 单独看做一个 token 则只能写成get x这样展开后中间会多一个空格，这显然不是我们想要的。 对于第二个x，对于预处理来说，-&gt;和x天然的就是两个 token，而且按照 C 的语法两者之间是否有空格并不会产生影响。合并以后反而会产生一个内容为-&gt;foo的 token。-&gt;foo并不是一个合法的 token，标准规定这种情况属于 ill-formed。不同编译器处理方法不同，gcc, clang 的预处理器会报错停止，vc会生成两个不同的 token。感兴趣的读者可以自己动手试验一下。 这一节的内容到此结束。到目前为止内容还比较简单，下一节的内容才是宏真正烧脑的地方。下节预告： object-like 宏的递归展开。 附录：什么是 token什么是 token？token 在编译原理中只语法符号或者语法标记。可以看做是用来标记某个语法成分的抽象，一般由 token 名和一些属性组成。比如说数字 1 可以认为是一个整数常量，token 名为integer-constant，且其属性值为 1。对于宏来说共有这么几种： identifier 标识符，这个和 C 语言的标识符定义一致 pp-number 预处理数字，其实和 C 语言中的数字也是类似的，区别在于多了一种情况，就是某种数字开头后跟非数字标识符的情况，比如 12aa，1.2bc 这种 character-constant 字符常量，就是’a’, ‘\n’ 等 string-literal 字符串字面量 “hello world” punctuator 标点符号 + - -&gt; &gt;&gt; 等 除了上边所列情况以外的所有非空白字符例如下边这个宏中的替换列表 token 化以后就是 [identifier] [punctuator] [pp-number] 1#define foo(x) x ## 12 object-like展开这里是这个系列的第二篇。这次我们开始关注一些更复杂的宏特性————object-like 宏的递归展开。 obj-like 的递归展开在替换列表中出现的宏会被展开，这一过程将递归的进行下去，且是深度优先的。例如： 123456789#define foo foz bar#define bar 123#define foz baz#define baz 1foo-&gt; foz bar-&gt; baz bar-&gt; 1 bar-&gt; 1 123 可以看到，当一个宏完全展开后，下一个宏才会被展开。但是，如果只有这一条规则那么很容易出现无限递归的情况。例如： 123456#define foo bar#define bar foofoo-&gt; bar-&gt; foo-&gt; 无限循环 因此在标准中对宏中涉及自指的部分做了限制： If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file’s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced. 16.3.4 cpp.recanISO n3690 从字面含义理解很简单，主要表达了两点： 在展开的过程中，如果替换列表中出现了被展开宏，那么该被展开宏不会被展开。 更进一步的，在展开的过程中，任何嵌套的展开过程中出现了被展开宏，该被展开宏也不会被展开。 听起来很绕不是么，这属于典型的，说起来绕但是实现起来简单。没关系，我们可以这样理解。每次展开的时候会创建一个「蓝色集合」（一般将标记过的 token 称作 painted-blue），这个蓝色集合由本次展开的父级展开的蓝色集合加上当前展开的宏组成。然后每次对替换列表进行扫描的时候，所有在当前蓝色集合中的宏都不会被展开。挺起来还是很绕的话，我们来看一个实际展开的例子： 1234#define foo foo a bar b bar baz c#define bar foo 12#define baz bar 13foo 定义三个宏 foo, bar, baz，展开过程如下图所示：]]></content>
      <categories>
        <category>C</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用C进行面向对象编程]]></title>
    <url>%2F2018%2F01%2F10%2F%E7%94%A8C%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为了解决编程的复杂性，自计算机发明以来，产生了三种编程范式：结构化编程、面向对象编程及函数式编程。长久以来，C语言都是被当作结构化编程典型，但是语言只是工具，编程范式更多提供给我们规划及编写代码的思路。本篇博客介绍了使用”结构化编程语言”：C语言，实现面向对象编程。 面向对象编程定义长久以来，面向对象被认为是数据与函数的结合，然而这个定义是十分荒谬的，你能说o.f()与f(o)是不同的么，很明显两者表述的是同一个事物。目前我没发现一个适合的定义，但是面向对象编程必有三个特性：封装，继承及多态。 OO语言三要素封装一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。可以防止外界调用端去访问对象内部实现。 继承继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。大大提高了代码的可重用性。 多态由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。 用C进行面向对象编程封装封装提高了代码的安全性，可以对外屏蔽具体的实现，在C语言中，代码分为头文件及对应的实现文件，利用此机制，可以做到封装： 1234567// person.hstruct Person;struct Person* newPerson(int age);void delPerson(struct Person* this);int getAge(struct Person* this);void setAge(struct Person* this, int age); 在person.h中，声明了Person结构体及对应的函数，person.h是数据与函数的结合，我们可以在person.c中实现对应的功能： 123456789101112131415161718192021struct Person &#123; int age;&#125;;struct Person* newPerson(int age)&#123; struct Person* p = malloc(sizeof(struct Person)); p-&gt;age = age; return p;&#125;void delPerson(struct Person* this)&#123; free(this);&#125;int getAge(struct Person* this)&#123; return this-&gt;age;&#125;void setAge(struct Person* this, int age)&#123; this-&gt;age = age;&#125; 相比较C++这类OO语言来说，C语言版本的封装可以认为是更加完美的封装，因为在person.h头文件里，完全没有暴露struct Person的相关定义，但是在C++这类OO语言中，必须要这么定义： 12345678910class Person&#123;private: int age;public: Person(int age); ~Person(); int getAge(); void setAge(int age);&#125; 暴露了Person的内部成员。 继承继承是子类自动包含父类的所有成员，可以认为子类是父类的超集。在C语言中两个结构体如果内存布局“相似”，如： 12345678struct Person &#123; int age;&#125;;struct Student&#123; int age; int cls;&#125;; Person与Student两个结构体，Student是Person的超集，两者的数据成员顺序相同，内存布局相似，基于此技巧，借助于强制类型转换，我们可以使用C语言实现继承： 123456789101112131415161718192021222324252627// person.hstruct Person;struct Person* newPerson(int age);void delPerson(struct Person* this);int getAge(struct Person* this);void setAge(struct Person* this, int age);// student.hstruct Student;struct Student* newStudent(int age, int cls);void setClass(struct Student* this, int cls);int getClass(struct Student* this);void delStudent(struct Student* this);// main.cint main(void)&#123; struct Student* stu = newStudent(10, 4); printf("Age: %d, Class: %d\n", getAge((struct Person*)stu), getClass(stu)); // inheritance, Student get method from Person setAge((struct Person*) stu, 15); setClass(stu, 9); printf("Age: %d, Class: %d\n", getAge((struct Person*)stu), getClass(stu)); delStudent(stu);&#125; 多态我们直接看个程序： 12345// file.hstruct File &#123; int (*read)(char* name, int size); void (*write)(char* name, int size);&#125;; 我们给出了File类型，其中包含了两个函数指针，则即给定了函数声明，这不就是OO语言中的接口么？ 123456789101112131415161718192021222324252627282930313233343536373839// console.cstatic int read(char* name, int size) &#123; printf("console read function, filename: %s, size: %d\n", name, size); return size;&#125;static void write(char* name, int size) &#123; printf("console write function, filename: %s, size: %d\n", name, size);&#125;struct File console = &#123;read, write&#125;;// socket.cstatic int read(char* name, int size) &#123; printf("socket read function, filename: %s, size: %d\n", name, size); return size;&#125;static void write(char* name, int size) &#123; printf("socket write function, filename: %s, size: %d\n", name, size);&#125;struct File socket = &#123;read, write&#125;;// STDIN.cextern struct File console;struct FILE* STDIN = (struct FILE*)&amp;console;// main.cint main(void) &#123; extern struct File* STDIN; STDIN-&gt;read("test.txt", 10); STDIN-&gt;write("test.txt", 100); extern struct File socket; STDIN = &amp;socket; STDIN-&gt;read("socket", 1000); STDIN-&gt;write("socket", 10);&#125; 可以看出通过STDIN指针指向不同的实现，就可以做出不同的响应，即多态。在C++中，多态的底层实现是通过虚表虚指针来实现的，与本实例同理。 总结面向对象编程是把这一些列的指针操作(最易出错的地方)隐藏在了底层，程序员接触不到。从语言层级提高了程序员的抽象能力。但是编程范式的发展限制了程序员可用的具体操作，如：OO编程范式把一系列的指针操作隐藏在底层。结构化程序设计使得我们只能用三种流程控制，远离goto人人有责。而函数式编程则禁止使用变量赋值。 代码地址：https://github.com/bjut-hz/C_OO 引用《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmake 教程]]></title>
    <url>%2F2017%2F03%2F11%2Fcmake-%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介摘自维基百科： CMake是个开源的跨平台自动化建构系统，它用配置文件控制建构过程（build process）的方式和Unix的Make相似，只是CMake的配置文件取名为CMakeLists.txt。Cmake并不直接建构出最终的软件，而是产生标准的建构档（如Unix的Makefile或Windows Visual C++的projects/workspaces），然后再依一般的建构方式使用。 “CMake”这个名字是”cross platform make”的缩写。虽然名字中含有”make”，但是CMake和Unix上常见的“make”系统是分开的，而且更为高级。 最近尝试了autoconf，automake，libtool等自动化构建工具，使用这些工具相比以前的手写Makefile来构建项目要简单了许多。但是，它们依然过于繁琐，而且对于跨平台来说不够友好。 之后突然想到在编译youcompleteme和neovim时用到的cmake命令，经过简单的学习发现cmake是一个很强大而且也比较简单的工项目构建工具。 这篇帖子是基于官方tutorial所写，扩充了官方文档中不太详细的部分。 Cmake的安装Cmake的安装非常的简单，官方已经提供了许多常用平台下的二进制文件发行版。 下载位置https://cmake.org/download/。 这里以当前最新的cmake3.5.2版本为例，如果你和我一样使用的是Linux那么只需要下载cmake-3.5.2-Linux-x86_64.tar.gz或cmake-3.5.2-Linux-i386.tar.gz，解压到任何一个你觉得合适的目录下，将解压后的bin文件夹添加到$PATH环境变量中即可。 Hello World 示例创建一个project文件夹作为项目的根文件夹，并在其中创建一个main.c文件，内容如下： 1234567#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; printf("Hello World!\n"); return 0;&#125; 使用Cmake来构建项目创建CMakeLists.txtCmake使用CMakeLists.txt文件来进行配置。对于我们的Hello World文件，CMakeLists.txt极为简单： 12345678# 用来构建该项目所用cmake的最低版本。cmake_minimum_required (VERSION 2.6)# 项目名project (Hello_World)# 使用main.c来生成hello。add_executable(hello main.c) 创建build文件夹Cmake的一个有点就是它会将所有的中间文件，例如.o文件等放在一个文件夹中，从而不会让项目的源码变得混乱。在这里我们使用build文件夹来保存所有的中间文件。 12mkdir buildcd build 开始构建项目在build文件夹中执行: 1cmake .. 这时会在build文件夹中生成一个Makefile文件（对于Linux用户来说，如果是其他用户可能会不同），下面只需要执行make命令就可以生成最终的二进制文件了。 1make 执行该二进制文件可以看到： 12./helloHello World! # Output 这时的文件树结构如下： 123456789.├── build│ ├── CMakeCache.txt│ ├── CMakeFiles│ ├── cmake_install.cmake│ ├── hello│ └── Makefile├── CMakeLists.txt└── main.c 多文件构建在实际的项目中，往往会有许多不同的子目录，用来保存项目不同模块的源码。使用cmake可以方便的管理这些分布在不同文件夹中的源码。 本文会使用cmake对多个不同文件夹下的c文件进行编译，最后再链接成二进制执行文件。 项目文件结构这次用到的文件目录结构如下： 1tree -L 2 1234567891011.├── build├── CMakeLists.txt├── include│ ├── echo.h│ └── operations.h├── lib│ ├── CMakeLists.txt│ ├── echo.c│ └── operations.c└── main.c 目录说明在该项目中，main()函数保存在main.c文件中。main.c文件通过#include来引用include/operations.h头文件和include/echo.h。 在include/operations.h头文件中，声明了一个int add(int, int)函数，该函数打印一行字符并返回两个整数的和。int add(int, int)的具体实现在lib/operations.c中。 在include/echo.h头文件中，声明了一个void echo(void)函数，该函数用来代替之前main函数中打印Hello World的功能，具体的定义保存在lib/echo.c中。 在cmake中，每一个包含有源文件的子目录都可以被当做一个子项目，因此每一个子目录也需要包含CMakeLists.txt文件用来说明当前子目录的情况。 子目录中的CMakeLists.txt会共享其父目录中的变量和设置。 新加入的文件 include/echo.h 123456#ifndef ECHO_H__#define ECHO_H__void echo(void);#endif include/operations.h 123456#ifndef OPERATIONS_H__#define OPERATIONS_H__int add(int, int);#endif lib/echo.c 123456#include &lt;stdio.h&gt;#include "../include/echo.h"void echo(void) &#123; printf("Hello World!\n");&#125; lib/operations.c 123456789#include &lt;stdio.h&gt;#include "../include/operations.h"int add(int a, int b) &#123; printf("Add opertion!\n"); return a + b;&#125;int add(int, int); CMakeLists.txt文件 lib中的CMakeLists.txt lib下的CMakeLists.txt内容很简单，仅包含下面一行： 12# 增加一个叫做**lib**的库目标（library target），并且这个库由**operations.c**和**echo.c**两个源文件生成。add_library (lib operations.c echo.c) 修改项目根目录下的CMakeLists.txt。 在根目录下的CMakeLists.txt中需要说明哪些目录是包含头文件的，哪些目录包含源文件。 添加如下内容： 1234567891011121314151617# 用来构建该项目所用cmake的最低版本。cmake_minimum_required (VERSION 2.6)# 项目名project (Hello_World)# 编译器用来寻找include文件的目录include_directories ("$&#123;PROJECT_SOURCE_DIR&#125;/include")# 添加包含源文件的子目录add_subdirectory ("$&#123;PROJECT_SOURCE_DIR&#125;/lib")# 使用main.c来生成hello。add_executable (hello main.c)# 链接target所需要的库target_link_libraries (hello lib) 构建项目构建方法可以前一样： 1234cd buildcmake ..make./hello 输出如下: 123Hello World!Add opertion!c = 3 分开编译不同的源文件之前使用add_library (lib operations.c echo.c)是将operations.c和echo.c一起编译成了liblib.a，然后在链接到最后的hello二进制文件中。 但是有时候，需要将不同的源文件编译成不同的库文件然后按需链接。这时需要修改lib/CMakeLists.txt为如下内容： 12add_library(echo echo.c)add_library(operations operations.c) 并且修改顶层CMakeLists.txt中的target_link_libraries()为如下内容： 1target_link_libraries (hello echo operations) 从而告诉cmakehello需要echo和operations两个库。 之后删除build文件夹内的内容，重新构建就好了。 变量与宏在cmake中内置了许多默认的变量，此外还可以根据自己的需要设置变量。cmake还可以根据模板文件自动替换其中的变量，从而实现自动添加版本号等功能。 变量 变量的定义与使用 在CMakeLists.txt中定义变量使用set()命令。 1set(变量名 值) 如果要使用变量，需要用以下方式： 1$&#123;变量名&#125; 内置变量 cmake内置了很多变量，这些变量可以直接拿来使用，具体的可以使用man命令来查看。 1man 7 cmake-variables 模板替换在实际的项目中，我们一般需要定义一个宏来说明当前的版本号。 在camke中，我们可以通过定义模板，在替换其中的指定部分来针对不同的编译参数使用不同的变量： 首先我们创建模板，cmake/config.h.in： 12#define PROJECT_VERSION_MAJOR @VERSION_MAJOR@#define PROJECT_VERSION_MINOR @VERSION_MINOR@ 其中的@...@部分会被替换。 之后我们在CMakeLists.txt中添加如下内容： 123456789# 设置变量名set (VERSION_MAJOR 2)set (VERSION_MINOR 0)# 复制config.h.in到config.h，并替换其中@中间的变量configure_file ( "$&#123;PROJECT_SOURCE_DIR&#125;/cmake/config.h.in" "$&#123;PROJECT_SOURCE_DIR&#125;/include/config.h" ) configure_file()会将config.h.in中的内容用之前设定的变量所替换，并将替换后的内容保存在include/config.h中。 宏变量很多情况下，我们需要根据条件来编译不同的模块。这里假设我们需要根据实际情况来选择是否要输出Hello World!。 我们可以设置一个叫做DUMP_HELLO的宏变量，来控制是否需要打印。 修改main.c如下： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include "include/config.h"#ifdef DUMP_HELLO#include "include/echo.h"#endif#include "include/operations.h"int main(int argc, char *argv[]) &#123; printf("The current of hello is %d.%d\n", PROJECT_VERSION_MAJOR, PROJECT_VERSION_MINOR);#ifdef DUMP_HELLO echo();#endif int a = 1, b = 2; int c = add(a, b); printf("c = %d\n", c); return 0;&#125; 我们可以通过修改模板config.h.in来控制是否定义该宏，在config.h.in中添加如下内容： 1#cmakedefine DUMP_HELLO 并在CMakeLists.txt中添加： 12option (DUMP_HELLO "print Hello World when execute" OFF) 注意这里我们设置其为OFF也就是不打印Hello World！。 既然不打印了，那也就不需要在编译echo.c这个文件了，我们可以在lib/CMakeLists.txt中修改如下： 123if (DUMP_HELLO) add_library(echo echo.c)endif (DUMP_HELLO) 这样就可以了。 文件的安装项目构建好之后，需要进行安装，使用cmake可以很方便的将不同类型的文件安装到不同的文件夹下。在本文中，我们要将生成的二进制文件安装到目标目录下的bin中，.h文件安装到include文件夹下，而生成的两个.a文件安装到lib中。 项目文件结构这次的项目文件结构和之前的相同： 1234567891011121314.├── build├── cmake│ └── config.h.in├── CMakeLists.txt├── include│ ├── config.h│ ├── echo.h│ └── operations.h├── lib│ ├── CMakeLists.txt│ ├── echo.c│ └── operations.c└── main.c CMAKE_INSTALL_PREFIX变量CMAKE_INSTALL_PREFIX变量是cmake的一个内置变量，它的作用和使用传统./configure安装时的--prefix=&lt;path&gt;作用是相同的，即指定文件的安装位置，在默认的情况下，该变量的位置是/usr/local/。 如果在安装时，要制定到其他位置，需要使用 1cmake -DCMAKE_INSTALL_PREFIX:PATH=&lt;path&gt; 操作过程 二进制文件和头文件的安装 我们最终生成的二进制文件名为hello，我们期望将它安装在bin目录中，那么需要在项目根目录下的CMakeList.txt中添加如下一行： 1install (TARGETS hello DESTINATION bin) 其中TARGETS为固定，TARGETS后面跟多个文件，这些文件将被安装到DESTINATION指定的文件夹中，也就是bin文件夹。这里的DESTINATION也是固定用法。 安装头文件与此类似： 1install (FILES "$&#123;PROJECT_SOURCE_DIR&#125;/include/config.h" DESTINATION include) 不过这里使用FILES而不是TARGETS。这里我们将项目目录下include/config.h文件安装到include文件夹中。 库文件的安装 由于我们的库文件在lib文件夹下，因此对于库文件的安装可以把install()命令写在lib文件夹下的CMakeList.txt中。 在lib/CMakeLists.txt修改为如下内容： 12345678if (DUMP_HELLO) add_library(echo echo.c) install (TARGETS echo DESTINATION lib)endif (DUMP_HELLO)add_library(operations operations.c)install (TARGETS operations DESTINATION lib) 重新编译安装假如我们要安装到/tmp/hello，那么执行： 1234cd buildcmake -DCMAKE_INSTALL_PREFIX:PATH=/tmp/hello ..makemake install 使用tree命令可以看到： 12345678/tmp/hello├── bin│ └── hello├── include│ └── config.h└── lib ├── libecho.a └── liboperations.a ¶ The end转自：https://d0u9.win/posts/858347849.html]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>cmake</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 高阶函数]]></title>
    <url>%2F2016%2F07%2F21%2FC%2B%2B%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式编程有很多优点，详情可以参考我的博文卡马克：《用C++ 进行函数式编程》。在C++中，我们可以借助于函数对象或者函数指针来实现高阶函数。 高阶函数是至少满足下列一个条件的函数: 接受一个或多个函数作为输入 输出一个函数 三种求和方式 1234567891011121314151617181920212223242526//公式（1）int sumInt( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i; &#125; return result;&#125;//公式（2）int sumCube( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i * i * i; &#125; return result;&#125;//公式（3）double sumPi( int a, int b )&#123; double result = 0; for ( int i = 1; i &lt;= b; i += 4 ) &#123; result += 1 / ( (double)(i) * (double)( i + 2 ) ); &#125; return result;&#125; 上述示例中，三个程序表面不同，但是程序包含的逻辑（对于不同序列进行求和）是相同的。对于计算机程序，这种类似就意味着抽象，进行更高层次的抽象，以较少重复劳动，减小出现错误的风险。 上述代码可以抽象为： 123456789//advanced abstractiontemplate &lt; class T, class F, class G &gt;T sumGeneric( T a, T b, F func, G next )&#123; T result( 0 ); for ( T i = a; i &lt;= b; next( i ) ) &#123; result += func( i ); &#125; return result;&#125; 上述代码，允许用户将循环体内的过程func和nex以参数的形式传入。只要它们能以函数的形式调用即可，在C++中，我们可以使用函数对象做到这一点。 实现如下：12345678910111213141516171819202122232425262728293031template &lt; class T &gt;class Self&#123;public: T operator()( T x )&#123; return x; &#125;&#125;;template &lt; class T &gt;class Cube&#123;public: T operator()( T x )&#123; return x*x*x; &#125;&#125;;template&lt; class T &gt;class MyFunc&#123;public: T operator()( T x )&#123; return 1 / ( x * ( x + 2 ) ); &#125;&#125;;template &lt; class T &gt;class Inc&#123;public: void operator()( T&amp; x )&#123; ++x; &#125;&#125;;template &lt; class T &gt;class Inc4&#123;public: void operator()( T&amp; x )&#123; x += 4; &#125;&#125;; 测试结果：1234567891011int main()&#123; cout &lt;&lt; "Normal Cal:" &lt;&lt; endl; cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumInt( 1, 50 ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumCube( 1, 50 ) &lt;&lt; " sumPi( 1, 50 ):" &lt;&lt; sumPi( 1, 50 ); cout &lt;&lt; endl &lt;&lt; "High Order Function:" &lt;&lt; endl; cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, Self&lt;int&gt;(), Inc&lt;int&gt;() ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, Cube&lt;int&gt;(), Inc&lt;int&gt;() ) &lt;&lt; " sumPi( 1, 50 ):" &lt;&lt; sumGeneric( (double)1, (double)50, MyFunc&lt;double&gt;(), Inc4&lt;double&gt;() ); system( "pause" );&#125; lambda表达式实现高阶函数 C++11在语言中加入了lambda表达式，我们可以借助与lambda表达式实现高阶函数。 参看我的博文C++ lambda表达式 代码下载地址：https://github.com/bjut-hz/High-Order-Function]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ lambda表达式]]></title>
    <url>%2F2016%2F06%2F20%2FC%2B%2B%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C++ 11在语言中加入了lambda表达式，lambda表达式可以方便地构造匿名函数。当我们定义lambda表达式时，C++编译器会创建一个匿名的与lambda表达式有关的类类型。 使用lambda表达式进行函数式编程我们知道，在函数式编程语言中，比如scheme，函数作为一等公民，与普通的数据类型相同，可以作为函数的参数以及返回值，可以很方便的实现高阶函数等。 在C++中，我们可以借助于函数对象以及函数指针实现。 在C ++11中，借助于lambda表达式，也可以实现高阶函数。 将lambda表达式用作返回值定义在头文件中的std::function是多态的函数对象包装，类似函数指针。它可以绑定至任何可以被调用的对象(仿函数、成员函数指针、函数指针和lambda表达式)，只要参数和返回类型符合包装的类型即可。返回一个double、接受两个整数参数的函数包装定义如下： 1function&lt; double(int, int) &gt; my_wrapper; 通过std::function，可以从函数中返回lambda表达式，示例如下： 1234function&lt;int(void)&gt; multiplyBy2Lambda(int x) &#123; return [=]()-&gt;int&#123; return 2 * x; &#125;; &#125; 这个函数的主体部分创建了一个lambda表达式，这个lambda表达式通过值捕捉所在作用域的变量，并返回一个整数，这个返回的整数是传给multiplyBy2Lambda()的值的两倍。这个multiplyBy2Lambda()函数的返回值类型为 function，即一个不接受参数并返回一个整数的函数。函数主体中定义的lambda表达式正好匹配这个原型。变量x通过值捕捉，因此，在lambda表达式从函数返回之前，x值的一份副本绑定至lambda表达式中的x。可以通过下述方式调用该函数： 12auto fun = multiplyBy2Lambda( 5 );cout &lt;&lt; fun(); //输出为10 将lambda表达式用作参数可以编写lambda表达式作为参数的函数。例如，可通过这种方式实现回调函数。下面的代码实现了一个testCallback()函数，这个函数接受一个整数vector和一个回调函数作为参数。这个实现迭代给定vector中的所有元素，并对每个元素调用回调函数，回调函数接受vector中每个元素作为int参数，并返回一个布尔值。如果回调函数返回false，那么停止迭代。 123456789101112//注意参数类型，第二个参数如果使用pass by reference，则必须加const修饰，否则编译错误//如果采用值传递，无影响void testCallback(const vector&lt;int&gt;&amp; vec, const function&lt;bool(int)&gt;&amp; callback) &#123; for (auto i : vec) &#123; if (!callback(i)) break; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; 测试： 123456auto callback = []( int i ) -&gt; bool &#123; return i &lt; 6; &#125;;vector&lt;int&gt; vec( 10 );int index = 0;generate( vec.begin(), vec.end(), [&amp;index] &#123;return ++index; &#125; );testCallback( vec, callback ); 结果： lambda表达式实现高阶函数有关C++ 高阶函数可以参看我的博文：C++ 高阶函数 12345678910111213141516171819202122232425int sumInt( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i; &#125; return result;&#125;int sumCube( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i * i * i; &#125; return result;&#125;//advanced abstractiontemplate &lt; class T &gt;T sumGeneric( T a, T b, const function&lt; int( int ) &gt;&amp; func, const function&lt; void( int&amp; ) &gt;&amp; next )&#123; T result( 0 ); for ( T i = a; i &lt;= b; next( i ) ) &#123; result += func( i ); &#125; return result;&#125; 上述示例中，前两个求和函数有着相同的逻辑，可以进行抽象sumGeneric。 测试： 12345678910auto self = []( int i ) -&gt; int &#123; return i; &#125;;auto inc = []( int&amp; i ) -&gt; void &#123; ++i; &#125;;auto cube = []( int i ) -&gt; int &#123; return i * i * i; &#125;;cout &lt;&lt; "Normal Cal:" &lt;&lt; endl;cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumInt( 1, 50 ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumCube( 1, 50 );cout &lt;&lt; endl &lt;&lt; "High Order Function:" &lt;&lt; endl;cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, self, inc ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, cube, inc ); 结果： 代码下载地址：https://github.com/bjut-hz/High-Order-Function]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类类型转换]]></title>
    <url>%2F2016%2F05%2F06%2FC%2B%2B%20%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[隐式类类型转换 在c++中，可以调用单参数构造函数，把指定类型转换为该类类型。这样的构造函数有时也被称为转换构造函数(converting constructors)。也就是说类的单参数构造函数，提供了把该形参类型转换为该类类型的一种方式。 最常见的例子： string name = “Bill”;在该例子中，由于string类提供了构造函数string (const char * s);因此存在字符串常量”Bill”到string类的隐式转换。 自定义类型示例： 12345678910111213141516class Sales_data &#123;public: Sales_data() = default; Sales_data( const std::string &amp;s ) : bookNo( s ) &#123; &#125; Sales_data( const std::string &amp;s, unsigned n, double p ) : bookNo( s ), units_sold( n ), revenue( p*n ) &#123; &#125; Sales_data( std::istream &amp; ); std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine( const Sales_data&amp; );private: std::string bookNo; unsigned units_sold; double revenue;&#125;; 在上述例子中，由于Sales_data( const std::string &amp;s )；构造函数的存在，因此存在string类型到Sales_data的转换，因此在需要Sales_data对象的时候，我们可以使用string类型替代。 123Sales_data item;string null_book = "9-999-99999-9";item.combine( null_book ); PS： 只有一次的隐式类类型转换是可行的，item.combine( “9-999-99999-9” );是错误的，因为在该语句中，存在着两次隐式转换，一次是字符串常量”9-999-99999-9”到string的转换，另一次是string到Sales_data的转换。 explicit constructors： 在你不想隐式转换，以防用户误操作怎么办？ C++提供了一种抑制构造函数隐式转换的办法，就是在构造函数前面加explicit关键字，你试试就知道，那时你再希望隐式转换就会导致编译失败，但是，要说明的是，显式转换还是可以进行。 类型转换函数类型转换函数(type conversion function)的作用是将一个类的对象转换成另一类型的数据 我们经常下述代码风格： 12while( cin &gt;&gt; num )&#123;&#125; 输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool();。 示例： 12345class Sales_data &#123;public: return true; &#125; &#125;; 类Sales_data定义了从该类对象到bool类型的转换，因此，在需要bool类型的表达式中可以使用该类对象代替： 12345Sales_data item;if ( item ) &#123; cout &lt;&lt; "true";&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡马克：用C++进行函数式编程]]></title>
    <url>%2F2016%2F04%2F05%2F%E5%8D%A1%E9%A9%AC%E5%85%8B%EF%BC%9A%E7%94%A8C%2B%2B%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[John Carmack，ID software创始人，这篇文章是John Carmack对函数式编程的一些看法。 导读：《Quake》作者 John Carmack (卡马克) 认为追求函数式编程的程序设计有着实实在在的价值，然而，劝说所有程序员抛弃他们的C++编译器，转而启用Lisp、Haskell，或者干脆说任何其他边缘语言，都是不负责任的。或许本文的每位读者都听说过，当初“函数式编程”（Functional Programming）肩负着为软件开发带来福祉的期望来到这个世界，大家可能还听说过有人将它奉为软件开发的银弹。然而，上维基百科查看更多信息却让人大倒胃口，一上来就引用λ演算和形式系统。很难一眼看出这跟编写更好的软件有什么关系。 我的实效性总结：软件开发中的大部分问题都缘于程序员没有完全理解程序执行中所有可能的状态。在多线程环境中，这一理解的缺失以及它所导致的问题变得更加严重，如果你留意这些问题，会发现它几乎严重到令人恐慌的地步。通过函数式的风格编写程序，可以将状态清晰地呈现给你的代码，从而使代码的逻辑更易于推理，而在纯粹的函数式系统中，这更使得线程竞争条件成为不可能的事情。 我确实相信追求函数式的程序设计有着实实在在的价值，然而劝说所有程序员抛弃C++编译器，转而启用Lisp、Haskell，或者干脆说任何其他边缘语言，那是不负责任的。让语言设计者永远懊恼的是，总会有大量的外在因素压跨一门语言的好处，相对大多数领域来说，游戏开发尤其如此。除了大家都要面对的遗留代码库和有限的人力资源问题之外，我们还有跨平台问题、私有工具链、证书网关、需要授权的技术，以及严酷的性能要求。 如果你的工作环境中可以用非主流语言完成主要开发任务，那应该为你欢呼，不过也等着打板子吧，罪名是项目进展方面的。而对所有其他人：不论你用何种语言工作，通过函数式的风格编写程序都会带来好处。任何时候，只要方便，就应当这么做；而不方便时，也应当仔细想想自己的决定。以后，只要愿意，你可以学学lambda、monad、currying、在无限集上合成懒惰式求值的函数，以及显式面向函数式语言的所有其他方面。 C++语言并不鼓励函数式程序设计，但它也不妨碍你这么做，而且为你保留了深入下层、运用SIMD内在函数基于内存映射文件直接布局数据的能力，或任何其他你发现自己用得着的精华特性。 纯函数纯函数是这样一种函数：它只会查看传进来的参数，它的全部行为就是返回基于参数计算出的一个或多个值。它没有逻辑副作用。这当然只是一种抽象；在CPU层面，每个函数都是有副作用的，多数函数在堆的层面上就有副作用，但这一抽象仍然有价值。 纯函数不查看也不更新全局状态，不维护内部状态，不执行任何I/O操作，也不更改任何输入参数。最好不要传递任何无关的数据给它——如果传一个allMyGlobals指针进来，这一目标就基本破灭了。 纯函数有许多良好的属性。 线程安全 使用值参数的纯函数是彻底线程安全的。使用引用或指针参数的话，就算是const的，你也应当知晓一个执行非纯操作的线程可能更改或释放其数据的风险。但即便是这种情况，纯函数仍不失为编写安全多线程代码的利器。你可以轻松地将一个纯函数替换为并行实现，或者运行多种实现并比较结果。这让代码的试验和演化都更加便利。 可测试性 纯函数具有引用透明性（referential transparency），也就是说，不论何时调用它，对于同一组参数它永远给出同样的结果，这使它跟那些与其他系统相互交织的东西比起来更易于使用。在编写测试代码的问题上，我从来没有特别尽责；太多代码与大量系统交互，以至于使用它们需要相当精细的控制，而我常常能够说服自己（也许不正确）这样的付出并不值得。纯函数很容易测试，其测试代码就像直接从教料书上摘抄下来的一样：构造一些输入并查看结果。每次遇到一小段目前看起来有些奇技淫巧的代码，我都会把它拆成一个单独的纯函数并编写测试。可怕的是，我常常发现这样的代码中存在问题，意味着我撒下的测试安全网还不够大。 可理解性与可维护性 输入和输出的限制使得纯函数在需要时更易于重新学习，由于文档不足而隐藏了外部信息的情况也会更少。 形式系统和软件的自动推理将来会越来越重要。静态代码分析今天已经很重要了，将代码转换成更加函数式的风格有助于工具对它的分析，或者至少能让速度更快的局部工具所覆盖的问题跟速度慢且更加昂贵的全局工具一样多。我们这个行业讲的是“把事情做出来”，我还看不到关于整个程序“正确性”的形式证明能成为切实的目标，但能够证明代码的特定部分不存在特定种类的问题也是很有价值的。我们可以在开发过程中多运用一些科学和数学成果。 正在修编程导论课的同学可能一边挠头一边想：“不是所有的程序都要这么写吗？”现实情况却是“大泥球”（Big Balls of Mud）程序多，架构清晰的程序少。传统的命令式编程语言为你提供了安全舱口，结果它们就总是被使用。如果你只是写一些用一下就扔掉的代码，那就怎么方便怎么来，用到全局状态也是常事。如果你在编写一年之后仍将使用的代码，那就要将眼前的便利因素跟日后不可避免的麻烦平衡一下了。大部分程序员都不擅长预测日后改动代码将会导致的各种痛苦。 “纯粹性”实践并非所有东西都可以是纯的，除非程序只操作自己的代码，否则到某个点总要与外部世界交互。尝试最大限度地推进代码的纯粹性可以带来难以想象的乐趣，然而，要达到一个务实的临界点，我们需要承认副作用到某一刻是必要的，然后有效地管理它们。 即使对某个特定的函数而言，这都不是一个“要么全有要么全无”的目标。随着一个函数的纯度不断提高，其价值可以连续增大，而且从“几乎纯粹”到“完全纯粹”带来的价值要低于从“意大利面条状态”到“基本纯粹”带来的价值。只要让函数朝着纯粹的目标前进，即使不能达到完全的纯度，也能改善你的代码。增减全局计数器或检查一个全局调试标志的函数是不纯的，但如果那是它唯一的不足，它仍然可以收获函数式的大部分好处。 避免在更大的上下文中造成最坏的结果通常比在有限的情形中达到完美状态更加重要。考虑一下你曾经对付过的最令人不爽的函数或系统，那种只有全副武装才能应付的，几乎可以确定，其中必有复杂的状态网络和代码行为所依赖的各种假设，而这些复杂性还不只发生在参数上。在这些方面强化一下约束，或至少努力防止更多的代码陷入类似的混乱局面，带来的影响将比挤压几个底层的数学函数大得多。 朝着纯粹性的目标重构代码，这一过程通常包含将计算从它所运行的环境中解脱出来，这几乎必然意味着更多的参数传递。似乎有点奇特——编程语言中的烦琐累赘已被人骂够了，而函数式编程却常常与代码体积的减少相关。函数式编程语言写的程序会比命令式语言的实现更加简洁，其中的因素与使用纯函数在很大程度上是正交的，这些因素包括垃圾回收、强大的内建类型、模式匹配、列表推导、函数合成以及各种语法糖等。程序体积的减少多半与函数式无关，某些命令式语言也能带来同样的效果。 如果你必须给一个函数传递十多个参数，恼火是应该的，你可以通过一些降低参数复杂性的方法来重构代码。C++中没有任何维护函数纯粹性的语言支持，这确实不太理想。如果有人通过一些不好的方法把一个大量使用的基础函数变得不再纯粹，所有使用这一函数的代码便统统失去了纯粹性。从形式系统的角度听起来这是灾难性的，但还是那句话，这并不是一念之恶便与佛无缘的那种“要么全有要么全无”的主张。很遗憾，大规模软件开发中的问题只能是统计意义上的。 看来未来的C/C++语言标准很有必要增加一个“pure”关键字。C++中已经有了一个近似的关键字const—一个支持编译时检查程序员意图的可选修饰符，加上它对代码百利而无一害。D语言倒是提供了一个“pure”关键字：http://www.d-programming-language.org/function.html。注意它们对弱纯粹性和强纯粹性的区分—要达到强纯粹，输入参数中的引用或指针需要使用const修饰。 从某些方面来看，语言关键字过于严格了—一个函数即使调用了非纯粹的函数也仍然可以是纯粹的，只要副作用不逃出函数之外即可。如果一个程序只处理命令行参数而不操作随机的文件系统状态，那么整个程序都可看做纯粹的函数式单元。 面向对象程序设计Michael Feathers（twitter @mfeathers）说：OO通过把移动的部件封装起来使代码可理解。FP通过把移动的部件减到最少使代码可理解。 “移动的部件”就是更改中的状态。通知一个对象改变自己，这是面向对象编程基础教材的第一课，在大多数程序员的观念中根深蒂固，但它却是一种反函数式的行为。将函数和它们操作的数据结构组织在一起，这一基本的OOP思想显然有其价值，但如果想在自己的部分代码中获得函数式编程的好处，那么在这些部分，你必须疏远一下某些面向对象的行为。 无法声明为const的类方法从定义上就是不纯的，因为它们要修改对象的部分或全部状态集合，这一集合可能十分庞大。它们也不是线程安全的，这里戳一下，那里捅一下，一点一点地把对象置成了非预期的状态，这种力量才真正是Bug的不竭之源。如果不考虑那个隐含的const this指针，从技术角度const对象方法仍可看做纯函数，但许多对象十分庞大，大到它本身就足以构成一种全局状态，从而弱化了纯函数的在简洁清晰上的一些好处。构造函数也可以是纯函数，通常应该努力使之成为纯函数——它们接受参数并返回一个对象。 从灵活编程的层面来看，你常常可以用更加函数式的方法使用对象，但可能需要一点接口上的改变。在id Software，我们曾有十年时间在使用一个idVec3类，它只有一个改变自己的void Normalize()方法，却没有相应的idVec3 Normalized() const方法。许多字符串方法也是以类似的方式定义的，它们操作自身，而不是返回执行过相应操作的一个新的副本——比如ToLowerCase()、StripFileExtension()等。 性能影响在任何情况下，直接修改内存块几乎都是无法逾越的最优方案，而不这么做就难免牺牲性能。多数时候这只有理论上的好处，我们一向都在用性能换生产率。 使用纯函数编程会导致更多的数据复制，出于性能方面的考虑，某些情况下这显然会成为不正确的实现策略。举个极端的例子，你可以写一个纯函数的DrawTriangle()，接受一个帧缓存（framebuffer）参数并返回一个全新的画上三角形的帧缓存作为结果。可别这么做。 按值返回一切结果是自然的函数式编程风格，然而总是依靠编译器实施返回值优化会对性能造成危害，因此对于函数输出的复杂数据结构，传递引用参数常常是合理的，但这么也有不好的一面：它阻止你将返回值声明为const以避免多次赋值。 很多时候人们都有强烈的欲望去更新传入的复杂结构中的某个值，而不是复制一份副本并返回修改后的版本，但这样等于舍弃了线程安全保障，因此不要轻易这么做。列表的产生倒是一种可以考虑就地更新的合理情形。往列表中追加新的元素，纯函数式的做法是返回尾端包含新元素的一个全新列表副本，原先的列表则保持不变。真正的函数式语言都在实现上运用了特别手法，从而使这种行为的后果没有听上去那么糟糕，但如果在典型的C++容器上这么做，那你就死定了。 一项重要的缓解因素是，如今性能意味着并行程序设计，相比单线程环境，并行程序即使在性能最优的情形中也需要更多的复制与合并操作，因此复制造成的损失减少了，而复杂性的降低和正确性的提高这两方面的好处相应增加了。例如，当开始考虑并行地运行一个游戏世界中的所有角色时，你就会渐渐明白，用面向对象的方法来更新对象，这在并行环境中难度很大。或许所有对象都引用了世界状态的一个只读版本，而在一帧结束时却复制了更新后的版本……嗨，等一下…… 如何行动在自己的代码库中检查某些有一定复杂度的函数，跟踪它能触及的每一比特外部状态以及所有可能的状态更新。即使对它不做一点改动，把这些信息放入一个注释块就已经是极好的文档了。如果函数能够——比方说，通过渲染系统触发一次屏幕刷新，你就可以直接把手举在空中，声明这个函数所有的正副作用已经超出了人类的理解力。你要着手的下一项任务是基于实际执行的计算从头开始重新考虑这个函数。收集所有的输入，把它传给一个纯函数，然后接收结果并做相应处理。 调试代码的时候，让自己着重了解那些更新的状态和隐藏的参数悄然登场，从而掩盖实际动作的部分。修改一些工具对象的代码，让函数返回新的副本而不是修改自身，除了迭代器，试着在自己使用的每个变量之前都加上const。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
</search>
