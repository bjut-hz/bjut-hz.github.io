<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用C进行面向对象编程]]></title>
    <url>%2F2018%2F01%2F10%2F%E7%94%A8C%E8%BF%9B%E8%A1%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为了解决编程的复杂性，自计算机发明以来，产生了三种编程范式：结构化编程、面向对象编程及函数式编程。长久以来，C语言都是被当作结构化编程典型，但是语言只是工具，编程范式更多提供给我们规划及编写代码的思路。本篇博客介绍了使用”结构化编程语言”：C语言，实现面向对象编程。 面向对象编程定义长久以来，面向对象被认为是数据与函数的结合，然而这个定义是十分荒谬的，你能说o.f()与f(o)是不同的么，很明显两者表述的是同一个事物。目前我没发现一个适合的定义，但是面向对象编程必有三个特性：封装，继承及多态。 OO语言三要素封装一种将抽象性函数接口的实现细节部分包装、隐藏起来的方法。可以防止外界调用端去访问对象内部实现。 继承继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。大大提高了代码的可重用性。 多态由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。 用C进行面向对象编程封装封装提高了代码的安全性，可以对外屏蔽具体的实现，在C语言中，代码分为头文件及对应的实现文件，利用此机制，可以做到封装： 1234567// person.hstruct Person;struct Person* newPerson(int age);void delPerson(struct Person* this);int getAge(struct Person* this);void setAge(struct Person* this, int age); 在person.h中，声明了Person结构体及对应的函数，person.h是数据与函数的结合，我们可以在person.c中实现对应的功能： 123456789101112131415161718192021struct Person &#123; int age;&#125;;struct Person* newPerson(int age)&#123; struct Person* p = malloc(sizeof(struct Person)); p-&gt;age = age; return p;&#125;void delPerson(struct Person* this)&#123; free(this);&#125;int getAge(struct Person* this)&#123; return this-&gt;age;&#125;void setAge(struct Person* this, int age)&#123; this-&gt;age = age;&#125; 相比较C++这类OO语言来说，C语言版本的封装可以认为是更加完美的封装，因为在person.h头文件里，完全没有暴露struct Person的相关定义，但是在C++这类OO语言中，必须要这么定义： 12345678910class Person&#123;private: int age;public: Person(int age); ~Person(); int getAge(); void setAge(int age);&#125; 暴露了Person的内部成员。 继承继承是子类自动包含父类的所有成员，可以认为子类是父类的超集。在C语言中两个结构体如果内存布局“相似”，如： 12345678struct Person &#123; int age;&#125;;struct Student&#123; int age; int cls;&#125;; Person与Student两个结构体，Student是Person的超集，两者的数据成员顺序相同，内存布局相似，基于此技巧，借助于强制类型转换，我们可以使用C语言实现继承： 123456789101112131415161718192021222324252627// person.hstruct Person;struct Person* newPerson(int age);void delPerson(struct Person* this);int getAge(struct Person* this);void setAge(struct Person* this, int age);// student.hstruct Student;struct Student* newStudent(int age, int cls);void setClass(struct Student* this, int cls);int getClass(struct Student* this);void delStudent(struct Student* this);// main.cint main(void)&#123; struct Student* stu = newStudent(10, 4); printf("Age: %d, Class: %d\n", getAge((struct Person*)stu), getClass(stu)); // inheritance, Student get method from Person setAge((struct Person*) stu, 15); setClass(stu, 9); printf("Age: %d, Class: %d\n", getAge((struct Person*)stu), getClass(stu)); delStudent(stu);&#125; 多态我们直接看个程序： 12345// file.hstruct File &#123; int (*read)(char* name, int size); void (*write)(char* name, int size);&#125;; 我们给出了File类型，其中包含了两个函数指针，则即给定了函数声明，这不就是OO语言中的接口么？ 123456789101112131415161718192021222324252627282930313233343536373839// console.cstatic int read(char* name, int size) &#123; printf("console read function, filename: %s, size: %d\n", name, size); return size;&#125;static void write(char* name, int size) &#123; printf("console write function, filename: %s, size: %d\n", name, size);&#125;struct File console = &#123;read, write&#125;;// socket.cstatic int read(char* name, int size) &#123; printf("socket read function, filename: %s, size: %d\n", name, size); return size;&#125;static void write(char* name, int size) &#123; printf("socket write function, filename: %s, size: %d\n", name, size);&#125;struct File socket = &#123;read, write&#125;;// STDIN.cextern struct File console;struct FILE* STDIN = (struct FILE*)&amp;console;// main.cint main(void) &#123; extern struct File* STDIN; STDIN-&gt;read("test.txt", 10); STDIN-&gt;write("test.txt", 100); extern struct File socket; STDIN = &amp;socket; STDIN-&gt;read("socket", 1000); STDIN-&gt;write("socket", 10);&#125; 可以看出通过STDIN指针指向不同的实现，就可以做出不同的响应，即多态。在C++中，多态的底层实现是通过虚表虚指针来实现的，与本实例同理。 总结面向对象编程是把这一些列的指针操作(最易出错的地方)隐藏在了底层，程序员接触不到。从语言层级提高了程序员的抽象能力。但是编程范式的发展限制了程序员可用的具体操作，如：OO编程范式把一系列的指针操作隐藏在底层。结构化程序设计使得我们只能用三种流程控制，远离goto人人有责。而函数式编程则禁止使用变量赋值。 代码地址：https://github.com/bjut-hz/C_OO 引用《Clean Architecture: A Craftsman’s Guide to Software Structure and Design》]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 高阶函数]]></title>
    <url>%2F2016%2F07%2F21%2FC%2B%2B%20%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数式编程有很多优点，详情可以参考我的博文卡马克：《用C++ 进行函数式编程》。在C++中，我们可以借助于函数对象或者函数指针来实现高阶函数。 高阶函数是至少满足下列一个条件的函数: 接受一个或多个函数作为输入 输出一个函数 三种求和方式 1234567891011121314151617181920212223242526//公式（1）int sumInt( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i; &#125; return result;&#125;//公式（2）int sumCube( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i * i * i; &#125; return result;&#125;//公式（3）double sumPi( int a, int b )&#123; double result = 0; for ( int i = 1; i &lt;= b; i += 4 ) &#123; result += 1 / ( (double)(i) * (double)( i + 2 ) ); &#125; return result;&#125; 上述示例中，三个程序表面不同，但是程序包含的逻辑（对于不同序列进行求和）是相同的。对于计算机程序，这种类似就意味着抽象，进行更高层次的抽象，以较少重复劳动，减小出现错误的风险。 上述代码可以抽象为： 123456789//advanced abstractiontemplate &lt; class T, class F, class G &gt;T sumGeneric( T a, T b, F func, G next )&#123; T result( 0 ); for ( T i = a; i &lt;= b; next( i ) ) &#123; result += func( i ); &#125; return result;&#125; 上述代码，允许用户将循环体内的过程func和nex以参数的形式传入。只要它们能以函数的形式调用即可，在C++中，我们可以使用函数对象做到这一点。 实现如下：12345678910111213141516171819202122232425262728293031template &lt; class T &gt;class Self&#123;public: T operator()( T x )&#123; return x; &#125;&#125;;template &lt; class T &gt;class Cube&#123;public: T operator()( T x )&#123; return x*x*x; &#125;&#125;;template&lt; class T &gt;class MyFunc&#123;public: T operator()( T x )&#123; return 1 / ( x * ( x + 2 ) ); &#125;&#125;;template &lt; class T &gt;class Inc&#123;public: void operator()( T&amp; x )&#123; ++x; &#125;&#125;;template &lt; class T &gt;class Inc4&#123;public: void operator()( T&amp; x )&#123; x += 4; &#125;&#125;; 测试结果：1234567891011int main()&#123; cout &lt;&lt; "Normal Cal:" &lt;&lt; endl; cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumInt( 1, 50 ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumCube( 1, 50 ) &lt;&lt; " sumPi( 1, 50 ):" &lt;&lt; sumPi( 1, 50 ); cout &lt;&lt; endl &lt;&lt; "High Order Function:" &lt;&lt; endl; cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, Self&lt;int&gt;(), Inc&lt;int&gt;() ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, Cube&lt;int&gt;(), Inc&lt;int&gt;() ) &lt;&lt; " sumPi( 1, 50 ):" &lt;&lt; sumGeneric( (double)1, (double)50, MyFunc&lt;double&gt;(), Inc4&lt;double&gt;() ); system( "pause" );&#125; lambda表达式实现高阶函数 C++11在语言中加入了lambda表达式，我们可以借助与lambda表达式实现高阶函数。 参看我的博文C++ lambda表达式 代码下载地址：https://github.com/bjut-hz/High-Order-Function]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ lambda表达式]]></title>
    <url>%2F2016%2F06%2F20%2FC%2B%2B%20lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C++ 11在语言中加入了lambda表达式，lambda表达式可以方便地构造匿名函数。当我们定义lambda表达式时，C++编译器会创建一个匿名的与lambda表达式有关的类类型。 使用lambda表达式进行函数式编程我们知道，在函数式编程语言中，比如scheme，函数作为一等公民，与普通的数据类型相同，可以作为函数的参数以及返回值，可以很方便的实现高阶函数等。 在C++中，我们可以借助于函数对象以及函数指针实现。 在C ++11中，借助于lambda表达式，也可以实现高阶函数。 将lambda表达式用作返回值定义在头文件中的std::function是多态的函数对象包装，类似函数指针。它可以绑定至任何可以被调用的对象(仿函数、成员函数指针、函数指针和lambda表达式)，只要参数和返回类型符合包装的类型即可。返回一个double、接受两个整数参数的函数包装定义如下： 1function&lt; double(int, int) &gt; my_wrapper; 通过std::function，可以从函数中返回lambda表达式，示例如下： 1234function&lt;int(void)&gt; multiplyBy2Lambda(int x) &#123; return [=]()-&gt;int&#123; return 2 * x; &#125;; &#125; 这个函数的主体部分创建了一个lambda表达式，这个lambda表达式通过值捕捉所在作用域的变量，并返回一个整数，这个返回的整数是传给multiplyBy2Lambda()的值的两倍。这个multiplyBy2Lambda()函数的返回值类型为 function，即一个不接受参数并返回一个整数的函数。函数主体中定义的lambda表达式正好匹配这个原型。变量x通过值捕捉，因此，在lambda表达式从函数返回之前，x值的一份副本绑定至lambda表达式中的x。可以通过下述方式调用该函数： 12auto fun = multiplyBy2Lambda( 5 );cout &lt;&lt; fun(); //输出为10 将lambda表达式用作参数可以编写lambda表达式作为参数的函数。例如，可通过这种方式实现回调函数。下面的代码实现了一个testCallback()函数，这个函数接受一个整数vector和一个回调函数作为参数。这个实现迭代给定vector中的所有元素，并对每个元素调用回调函数，回调函数接受vector中每个元素作为int参数，并返回一个布尔值。如果回调函数返回false，那么停止迭代。 123456789101112//注意参数类型，第二个参数如果使用pass by reference，则必须加const修饰，否则编译错误//如果采用值传递，无影响void testCallback(const vector&lt;int&gt;&amp; vec, const function&lt;bool(int)&gt;&amp; callback) &#123; for (auto i : vec) &#123; if (!callback(i)) break; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; 测试： 123456auto callback = []( int i ) -&gt; bool &#123; return i &lt; 6; &#125;;vector&lt;int&gt; vec( 10 );int index = 0;generate( vec.begin(), vec.end(), [&amp;index] &#123;return ++index; &#125; );testCallback( vec, callback ); 结果： lambda表达式实现高阶函数有关C++ 高阶函数可以参看我的博文：C++ 高阶函数 12345678910111213141516171819202122232425int sumInt( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i; &#125; return result;&#125;int sumCube( int a, int b )&#123; int result &#123; 0 &#125;; for ( int i = a; i &lt;= b; ++i ) &#123; result += i * i * i; &#125; return result;&#125;//advanced abstractiontemplate &lt; class T &gt;T sumGeneric( T a, T b, const function&lt; int( int ) &gt;&amp; func, const function&lt; void( int&amp; ) &gt;&amp; next )&#123; T result( 0 ); for ( T i = a; i &lt;= b; next( i ) ) &#123; result += func( i ); &#125; return result;&#125; 上述示例中，前两个求和函数有着相同的逻辑，可以进行抽象sumGeneric。 测试： 12345678910auto self = []( int i ) -&gt; int &#123; return i; &#125;;auto inc = []( int&amp; i ) -&gt; void &#123; ++i; &#125;;auto cube = []( int i ) -&gt; int &#123; return i * i * i; &#125;;cout &lt;&lt; "Normal Cal:" &lt;&lt; endl;cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumInt( 1, 50 ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumCube( 1, 50 );cout &lt;&lt; endl &lt;&lt; "High Order Function:" &lt;&lt; endl;cout &lt;&lt; "sumInt( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, self, inc ) &lt;&lt; " sumCube( 1, 50 ):" &lt;&lt; sumGeneric( 1, 50, cube, inc ); 结果： 代码下载地址：https://github.com/bjut-hz/High-Order-Function]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类类型转换]]></title>
    <url>%2F2016%2F05%2F06%2FC%2B%2B%20%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[隐式类类型转换 在c++中，可以调用单参数构造函数，把指定类型转换为该类类型。这样的构造函数有时也被称为转换构造函数(converting constructors)。也就是说类的单参数构造函数，提供了把该形参类型转换为该类类型的一种方式。 最常见的例子： string name = “Bill”;在该例子中，由于string类提供了构造函数string (const char * s);因此存在字符串常量”Bill”到string类的隐式转换。 自定义类型示例： 12345678910111213141516class Sales_data &#123;public: Sales_data() = default; Sales_data( const std::string &amp;s ) : bookNo( s ) &#123; &#125; Sales_data( const std::string &amp;s, unsigned n, double p ) : bookNo( s ), units_sold( n ), revenue( p*n ) &#123; &#125; Sales_data( std::istream &amp; ); std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine( const Sales_data&amp; );private: std::string bookNo; unsigned units_sold; double revenue;&#125;; 在上述例子中，由于Sales_data( const std::string &amp;s )；构造函数的存在，因此存在string类型到Sales_data的转换，因此在需要Sales_data对象的时候，我们可以使用string类型替代。 123Sales_data item;string null_book = "9-999-99999-9";item.combine( null_book ); PS： 只有一次的隐式类类型转换是可行的，item.combine( “9-999-99999-9” );是错误的，因为在该语句中，存在着两次隐式转换，一次是字符串常量”9-999-99999-9”到string的转换，另一次是string到Sales_data的转换。 explicit constructors： 在你不想隐式转换，以防用户误操作怎么办？ C++提供了一种抑制构造函数隐式转换的办法，就是在构造函数前面加explicit关键字，你试试就知道，那时你再希望隐式转换就会导致编译失败，但是，要说明的是，显式转换还是可以进行。 类型转换函数类型转换函数(type conversion function)的作用是将一个类的对象转换成另一类型的数据 我们经常下述代码风格： 12while( cin &gt;&gt; num )&#123;&#125; 输入操作符 &gt;&gt; 是二元操作符，返回做操作数作为其表达式结果，因此cin &gt;&gt; num返回cin,然而cin是输入流istream的对象，该对象能出现在条件表达式中，是因为在istream中定义了类型转换函数 operator bool();。 示例： 12345class Sales_data &#123;public: return true; &#125; &#125;; 类Sales_data定义了从该类对象到bool类型的转换，因此，在需要bool类型的表达式中可以使用该类对象代替： 12345Sales_data item;if ( item ) &#123; cout &lt;&lt; "true";&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>隐式转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡马克：用C++进行函数式编程]]></title>
    <url>%2F2016%2F04%2F05%2F%E5%8D%A1%E9%A9%AC%E5%85%8B%EF%BC%9A%E7%94%A8C%2B%2B%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[John Carmack，ID software创始人，这篇文章是John Carmack对函数式编程的一些看法。 导读：《Quake》作者 John Carmack (卡马克) 认为追求函数式编程的程序设计有着实实在在的价值，然而，劝说所有程序员抛弃他们的C++编译器，转而启用Lisp、Haskell，或者干脆说任何其他边缘语言，都是不负责任的。或许本文的每位读者都听说过，当初“函数式编程”（Functional Programming）肩负着为软件开发带来福祉的期望来到这个世界，大家可能还听说过有人将它奉为软件开发的银弹。然而，上维基百科查看更多信息却让人大倒胃口，一上来就引用λ演算和形式系统。很难一眼看出这跟编写更好的软件有什么关系。 我的实效性总结：软件开发中的大部分问题都缘于程序员没有完全理解程序执行中所有可能的状态。在多线程环境中，这一理解的缺失以及它所导致的问题变得更加严重，如果你留意这些问题，会发现它几乎严重到令人恐慌的地步。通过函数式的风格编写程序，可以将状态清晰地呈现给你的代码，从而使代码的逻辑更易于推理，而在纯粹的函数式系统中，这更使得线程竞争条件成为不可能的事情。 我确实相信追求函数式的程序设计有着实实在在的价值，然而劝说所有程序员抛弃C++编译器，转而启用Lisp、Haskell，或者干脆说任何其他边缘语言，那是不负责任的。让语言设计者永远懊恼的是，总会有大量的外在因素压跨一门语言的好处，相对大多数领域来说，游戏开发尤其如此。除了大家都要面对的遗留代码库和有限的人力资源问题之外，我们还有跨平台问题、私有工具链、证书网关、需要授权的技术，以及严酷的性能要求。 如果你的工作环境中可以用非主流语言完成主要开发任务，那应该为你欢呼，不过也等着打板子吧，罪名是项目进展方面的。而对所有其他人：不论你用何种语言工作，通过函数式的风格编写程序都会带来好处。任何时候，只要方便，就应当这么做；而不方便时，也应当仔细想想自己的决定。以后，只要愿意，你可以学学lambda、monad、currying、在无限集上合成懒惰式求值的函数，以及显式面向函数式语言的所有其他方面。 C++语言并不鼓励函数式程序设计，但它也不妨碍你这么做，而且为你保留了深入下层、运用SIMD内在函数基于内存映射文件直接布局数据的能力，或任何其他你发现自己用得着的精华特性。 纯函数纯函数是这样一种函数：它只会查看传进来的参数，它的全部行为就是返回基于参数计算出的一个或多个值。它没有逻辑副作用。这当然只是一种抽象；在CPU层面，每个函数都是有副作用的，多数函数在堆的层面上就有副作用，但这一抽象仍然有价值。 纯函数不查看也不更新全局状态，不维护内部状态，不执行任何I/O操作，也不更改任何输入参数。最好不要传递任何无关的数据给它——如果传一个allMyGlobals指针进来，这一目标就基本破灭了。 纯函数有许多良好的属性。 线程安全 使用值参数的纯函数是彻底线程安全的。使用引用或指针参数的话，就算是const的，你也应当知晓一个执行非纯操作的线程可能更改或释放其数据的风险。但即便是这种情况，纯函数仍不失为编写安全多线程代码的利器。你可以轻松地将一个纯函数替换为并行实现，或者运行多种实现并比较结果。这让代码的试验和演化都更加便利。 可测试性 纯函数具有引用透明性（referential transparency），也就是说，不论何时调用它，对于同一组参数它永远给出同样的结果，这使它跟那些与其他系统相互交织的东西比起来更易于使用。在编写测试代码的问题上，我从来没有特别尽责；太多代码与大量系统交互，以至于使用它们需要相当精细的控制，而我常常能够说服自己（也许不正确）这样的付出并不值得。纯函数很容易测试，其测试代码就像直接从教料书上摘抄下来的一样：构造一些输入并查看结果。每次遇到一小段目前看起来有些奇技淫巧的代码，我都会把它拆成一个单独的纯函数并编写测试。可怕的是，我常常发现这样的代码中存在问题，意味着我撒下的测试安全网还不够大。 可理解性与可维护性 输入和输出的限制使得纯函数在需要时更易于重新学习，由于文档不足而隐藏了外部信息的情况也会更少。 形式系统和软件的自动推理将来会越来越重要。静态代码分析今天已经很重要了，将代码转换成更加函数式的风格有助于工具对它的分析，或者至少能让速度更快的局部工具所覆盖的问题跟速度慢且更加昂贵的全局工具一样多。我们这个行业讲的是“把事情做出来”，我还看不到关于整个程序“正确性”的形式证明能成为切实的目标，但能够证明代码的特定部分不存在特定种类的问题也是很有价值的。我们可以在开发过程中多运用一些科学和数学成果。 正在修编程导论课的同学可能一边挠头一边想：“不是所有的程序都要这么写吗？”现实情况却是“大泥球”（Big Balls of Mud）程序多，架构清晰的程序少。传统的命令式编程语言为你提供了安全舱口，结果它们就总是被使用。如果你只是写一些用一下就扔掉的代码，那就怎么方便怎么来，用到全局状态也是常事。如果你在编写一年之后仍将使用的代码，那就要将眼前的便利因素跟日后不可避免的麻烦平衡一下了。大部分程序员都不擅长预测日后改动代码将会导致的各种痛苦。 “纯粹性”实践并非所有东西都可以是纯的，除非程序只操作自己的代码，否则到某个点总要与外部世界交互。尝试最大限度地推进代码的纯粹性可以带来难以想象的乐趣，然而，要达到一个务实的临界点，我们需要承认副作用到某一刻是必要的，然后有效地管理它们。 即使对某个特定的函数而言，这都不是一个“要么全有要么全无”的目标。随着一个函数的纯度不断提高，其价值可以连续增大，而且从“几乎纯粹”到“完全纯粹”带来的价值要低于从“意大利面条状态”到“基本纯粹”带来的价值。只要让函数朝着纯粹的目标前进，即使不能达到完全的纯度，也能改善你的代码。增减全局计数器或检查一个全局调试标志的函数是不纯的，但如果那是它唯一的不足，它仍然可以收获函数式的大部分好处。 避免在更大的上下文中造成最坏的结果通常比在有限的情形中达到完美状态更加重要。考虑一下你曾经对付过的最令人不爽的函数或系统，那种只有全副武装才能应付的，几乎可以确定，其中必有复杂的状态网络和代码行为所依赖的各种假设，而这些复杂性还不只发生在参数上。在这些方面强化一下约束，或至少努力防止更多的代码陷入类似的混乱局面，带来的影响将比挤压几个底层的数学函数大得多。 朝着纯粹性的目标重构代码，这一过程通常包含将计算从它所运行的环境中解脱出来，这几乎必然意味着更多的参数传递。似乎有点奇特——编程语言中的烦琐累赘已被人骂够了，而函数式编程却常常与代码体积的减少相关。函数式编程语言写的程序会比命令式语言的实现更加简洁，其中的因素与使用纯函数在很大程度上是正交的，这些因素包括垃圾回收、强大的内建类型、模式匹配、列表推导、函数合成以及各种语法糖等。程序体积的减少多半与函数式无关，某些命令式语言也能带来同样的效果。 如果你必须给一个函数传递十多个参数，恼火是应该的，你可以通过一些降低参数复杂性的方法来重构代码。C++中没有任何维护函数纯粹性的语言支持，这确实不太理想。如果有人通过一些不好的方法把一个大量使用的基础函数变得不再纯粹，所有使用这一函数的代码便统统失去了纯粹性。从形式系统的角度听起来这是灾难性的，但还是那句话，这并不是一念之恶便与佛无缘的那种“要么全有要么全无”的主张。很遗憾，大规模软件开发中的问题只能是统计意义上的。 看来未来的C/C++语言标准很有必要增加一个“pure”关键字。C++中已经有了一个近似的关键字const—一个支持编译时检查程序员意图的可选修饰符，加上它对代码百利而无一害。D语言倒是提供了一个“pure”关键字：http://www.d-programming-language.org/function.html。注意它们对弱纯粹性和强纯粹性的区分—要达到强纯粹，输入参数中的引用或指针需要使用const修饰。 从某些方面来看，语言关键字过于严格了—一个函数即使调用了非纯粹的函数也仍然可以是纯粹的，只要副作用不逃出函数之外即可。如果一个程序只处理命令行参数而不操作随机的文件系统状态，那么整个程序都可看做纯粹的函数式单元。 面向对象程序设计Michael Feathers（twitter @mfeathers）说：OO通过把移动的部件封装起来使代码可理解。FP通过把移动的部件减到最少使代码可理解。 “移动的部件”就是更改中的状态。通知一个对象改变自己，这是面向对象编程基础教材的第一课，在大多数程序员的观念中根深蒂固，但它却是一种反函数式的行为。将函数和它们操作的数据结构组织在一起，这一基本的OOP思想显然有其价值，但如果想在自己的部分代码中获得函数式编程的好处，那么在这些部分，你必须疏远一下某些面向对象的行为。 无法声明为const的类方法从定义上就是不纯的，因为它们要修改对象的部分或全部状态集合，这一集合可能十分庞大。它们也不是线程安全的，这里戳一下，那里捅一下，一点一点地把对象置成了非预期的状态，这种力量才真正是Bug的不竭之源。如果不考虑那个隐含的const this指针，从技术角度const对象方法仍可看做纯函数，但许多对象十分庞大，大到它本身就足以构成一种全局状态，从而弱化了纯函数的在简洁清晰上的一些好处。构造函数也可以是纯函数，通常应该努力使之成为纯函数——它们接受参数并返回一个对象。 从灵活编程的层面来看，你常常可以用更加函数式的方法使用对象，但可能需要一点接口上的改变。在id Software，我们曾有十年时间在使用一个idVec3类，它只有一个改变自己的void Normalize()方法，却没有相应的idVec3 Normalized() const方法。许多字符串方法也是以类似的方式定义的，它们操作自身，而不是返回执行过相应操作的一个新的副本——比如ToLowerCase()、StripFileExtension()等。 性能影响在任何情况下，直接修改内存块几乎都是无法逾越的最优方案，而不这么做就难免牺牲性能。多数时候这只有理论上的好处，我们一向都在用性能换生产率。 使用纯函数编程会导致更多的数据复制，出于性能方面的考虑，某些情况下这显然会成为不正确的实现策略。举个极端的例子，你可以写一个纯函数的DrawTriangle()，接受一个帧缓存（framebuffer）参数并返回一个全新的画上三角形的帧缓存作为结果。可别这么做。 按值返回一切结果是自然的函数式编程风格，然而总是依靠编译器实施返回值优化会对性能造成危害，因此对于函数输出的复杂数据结构，传递引用参数常常是合理的，但这么也有不好的一面：它阻止你将返回值声明为const以避免多次赋值。 很多时候人们都有强烈的欲望去更新传入的复杂结构中的某个值，而不是复制一份副本并返回修改后的版本，但这样等于舍弃了线程安全保障，因此不要轻易这么做。列表的产生倒是一种可以考虑就地更新的合理情形。往列表中追加新的元素，纯函数式的做法是返回尾端包含新元素的一个全新列表副本，原先的列表则保持不变。真正的函数式语言都在实现上运用了特别手法，从而使这种行为的后果没有听上去那么糟糕，但如果在典型的C++容器上这么做，那你就死定了。 一项重要的缓解因素是，如今性能意味着并行程序设计，相比单线程环境，并行程序即使在性能最优的情形中也需要更多的复制与合并操作，因此复制造成的损失减少了，而复杂性的降低和正确性的提高这两方面的好处相应增加了。例如，当开始考虑并行地运行一个游戏世界中的所有角色时，你就会渐渐明白，用面向对象的方法来更新对象，这在并行环境中难度很大。或许所有对象都引用了世界状态的一个只读版本，而在一帧结束时却复制了更新后的版本……嗨，等一下…… 如何行动在自己的代码库中检查某些有一定复杂度的函数，跟踪它能触及的每一比特外部状态以及所有可能的状态更新。即使对它不做一点改动，把这些信息放入一个注释块就已经是极好的文档了。如果函数能够——比方说，通过渲染系统触发一次屏幕刷新，你就可以直接把手举在空中，声明这个函数所有的正副作用已经超出了人类的理解力。你要着手的下一项任务是基于实际执行的计算从头开始重新考虑这个函数。收集所有的输入，把它传给一个纯函数，然后接收结果并做相应处理。 调试代码的时候，让自己着重了解那些更新的状态和隐藏的参数悄然登场，从而掩盖实际动作的部分。修改一些工具对象的代码，让函数返回新的副本而不是修改自身，除了迭代器，试着在自己使用的每个变量之前都加上const。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
</search>
