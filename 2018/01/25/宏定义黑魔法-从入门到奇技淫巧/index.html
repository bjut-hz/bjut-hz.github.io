<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="宏," />










<meta name="description" content="基础概念楔子最近在研究如何在 C++ 里边实现反射，结果发现了很多有意思的技巧。可惜其中相当一部分都是依赖于宏实现的，晦涩难懂。这个过程中断断续续查了很多资料，发现网上不管是中文还是英文都很少有资料对宏的用法有一个比较完整的介绍。特别是一些「奇技淫巧」类的惯用法。少数几个也没有原理上的分析，十分可惜。所以在这里将自己搜集到的东西整理成一个教程，以飨列位。随着教程的深入，你会发现宏的能力远超一般的认">
<meta name="keywords" content="宏">
<meta property="og:type" content="article">
<meta property="og:title" content="宏定义黑魔法-从入门到奇技淫巧">
<meta property="og:url" content="http://yoursite.com/2018/01/25/宏定义黑魔法-从入门到奇技淫巧/index.html">
<meta property="og:site_name" content="hz&#39;s blog">
<meta property="og:description" content="基础概念楔子最近在研究如何在 C++ 里边实现反射，结果发现了很多有意思的技巧。可惜其中相当一部分都是依赖于宏实现的，晦涩难懂。这个过程中断断续续查了很多资料，发现网上不管是中文还是英文都很少有资料对宏的用法有一个比较完整的介绍。特别是一些「奇技淫巧」类的惯用法。少数几个也没有原理上的分析，十分可惜。所以在这里将自己搜集到的东西整理成一个教程，以飨列位。随着教程的深入，你会发现宏的能力远超一般的认">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-01T07:48:10.343Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宏定义黑魔法-从入门到奇技淫巧">
<meta name="twitter:description" content="基础概念楔子最近在研究如何在 C++ 里边实现反射，结果发现了很多有意思的技巧。可惜其中相当一部分都是依赖于宏实现的，晦涩难懂。这个过程中断断续续查了很多资料，发现网上不管是中文还是英文都很少有资料对宏的用法有一个比较完整的介绍。特别是一些「奇技淫巧」类的惯用法。少数几个也没有原理上的分析，十分可惜。所以在这里将自己搜集到的东西整理成一个教程，以飨列位。随着教程的深入，你会发现宏的能力远超一般的认">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/25/宏定义黑魔法-从入门到奇技淫巧/"/>





  <title>宏定义黑魔法-从入门到奇技淫巧 | hz's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c6b14cead504cb7b4b5cdc81f3a68bf4";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hz's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/25/宏定义黑魔法-从入门到奇技淫巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="hz">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hz's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">宏定义黑魔法-从入门到奇技淫巧</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T11:24:26+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/25/宏定义黑魔法-从入门到奇技淫巧/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/01/25/宏定义黑魔法-从入门到奇技淫巧/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h3><p>最近在研究如何在 C++ 里边实现反射，结果发现了很多有意思的技巧。可惜其中相当一部分都是依赖于宏实现的，晦涩难懂。这个过程中断断续续查了很多资料，发现网上不管是中文还是英文都很少有资料对宏的用法有一个比较完整的介绍。特别是一些「奇技淫巧」类的惯用法。少数几个也没有原理上的分析，十分可惜。所以在这里将自己搜集到的东西整理成一个教程，以飨列位。随着教程的深入，你会发现宏的能力远超一般的认识。利用各种猥琐的技巧，可以使宏具有接近图灵完备语言的能力。</p>
<p>一般来说在 C++ 中是不提倡使用宏的，模板已经能够很好地替代宏的绝大多数功能了。宏由于其自身设计的原因，使用起来不仅晦涩难懂，而且还有很多难以预料的坑。那么现在是不是就没有学习宏的必要了呢？笔者认为答案是否定的。理由有三：其一，仍有一小部分功能模板无法替代宏来实现，且有的功能使用宏比模板更加的直观。其二，以前的遗留代码中有大量的宏，而这些库在今天依旧有着广泛的应用。其三，宏的很多惯用发思路清奇又猥琐，却又暗合编程语言理论，用来把玩也是很有趣的。</p>
<a id="more"></a>
<h3 id="宏的定义"><a href="#宏的定义" class="headerlink" title="宏的定义"></a>宏的定义</h3><p>绝大多数人对于宏的概念仅仅停留在简单替换的程度上，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 42</span></span><br><span class="line">N</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure>
<p>众所周知，这个宏的作用是找到源文件中所有的 N 然后将其替换为 42。然而，对于 C 和 C++ 的预处理需求来说，这种功能过于简单了。有时候我们希望能够根据不同的参数来进行某种模式的替换。这就产生了第二种宏，带参数的宏。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// obj-like</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 替换列表 换行符</span></span><br><span class="line"><span class="comment">//func-like</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 ([标识符列表]) 替换列表 换行符</span></span><br></pre></td></tr></table></figure>
<p>其中替换列表和标识符列表都是将字符串 token (如果对 token 这个概念比较陌生请看文章最后) 化以后的列表。区别在于标识符列表使用,作为不同参数之间的分割符。每一个参数都是一个 token 化的列表。</p>
<p>这里有两点值得注意的地方：1. 宏的内容会被 token 化成一个替换列表。也就是说，预处理器在处理宏展开时并不是以字符串的形式处理，而是以 token 列表的形式处理的。这对于我们理解宏的行为非常重要。例如，在宏中空白符只起到分割 token 的作用，空白符的多少对于预处理器是没有意义的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAIN      \</span></span><br><span class="line">int main()        \</span><br><span class="line">&#123;                 \</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，宏可以重复定义，但前提是两次定义的内容完全一致。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合法的二次定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO int foo;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO int       foo;</span></span><br><span class="line"><span class="comment">//重定义错误，有的编译器会给出警告并使用最后一次的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO int* foo;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO int foo;</span></span><br></pre></td></tr></table></figure>
<h3 id="宏的操作符"><a href="#宏的操作符" class="headerlink" title="宏的操作符"></a>宏的操作符</h3><p>和 C, C++ 语言本体不同，宏有着它自己特有的两个操作符。下边简单地介绍一下。</p>
<h3 id="字符串化操作符"><a href="#字符串化操作符" class="headerlink" title="字符串化操作符 #"></a>字符串化操作符 <code>#</code></h3><p>有时候我们希望能够讲参数转换为字符串进行处理，# 可以将一个 token 字符串化。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WARN_IF(EXP) \</span></span><br><span class="line">    <span class="keyword">if</span> (EXP) \</span><br><span class="line">    &#123;\</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Warning: "</span> #EXP <span class="string">"\n"</span>); \</span><br><span class="line">    &#125;\</span><br><span class="line">WARN_IF (x<span class="comment">/* const char* */</span> == <span class="string">"0"</span>)</span><br><span class="line"><span class="comment">// -&gt;</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">"0"</span>) &#123; <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">"Warning: "</span> <span class="string">"x == \"0\""</span> <span class="string">"\n"</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>此处有几点需要注意：</p>
<ol>
<li><code>#</code>操作符并不是简单的添加双引号，它会自动对特殊字符进行转义。</li>
<li><code>#</code>操作符只能对 func-like 的参数使用。</li>
<li>由于参数会转化为 token 列表，所以前后的空白符都会被忽略，中间的空白符会被压缩为一个，注释会被忽略并变成一个空白符。</li>
</ol>
<h3 id="Token-粘贴操作符"><a href="#Token-粘贴操作符" class="headerlink" title="Token 粘贴操作符"></a>Token 粘贴操作符</h3><p>然后我们再学习一个新的操作符 <code>##</code>，<code>##</code> 可以将两个 token 合并为一个。合并新的 token 有什么用呢？它可以提供给你动态的生成 token 的能力，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GETTER(x, T) T get_ ## x() &#123;return this-&gt;x;&#125;</span></span><br><span class="line">GETTER(foo， <span class="keyword">const</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="comment">//-&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">get_foo</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;foo;&#125;</span><br></pre></td></tr></table></figure>
<p>此处通过GETTER生成了一个对于属性x的访问器。当然，这并不是一个明智的做法，而且还有很多漏洞。但是它展示给了我们宏动态生成 token 的能力。</p>
<p>有人可能注意第一个x需要##来进行连接，第二个却不需要。这是因为预处理器以 token 列表的方式处理展开过程。对于第一个x如果不使用##，那么对于预处理器来说get_x只是一个内容为get<em>x的 token，x 并不会被替换。若需要将 x 单独看做一个 token 则只能写成get</em> x这样展开后中间会多一个空格，这显然不是我们想要的。</p>
<p>对于第二个x，对于预处理来说，-&gt;和x天然的就是两个 token，而且按照 C 的语法两者之间是否有空格并不会产生影响。合并以后反而会产生一个内容为-&gt;foo的 token。-&gt;foo并不是一个合法的 token，标准规定这种情况属于 ill-formed。不同编译器处理方法不同，gcc, clang 的预处理器会报错停止，vc会生成两个不同的 token。感兴趣的读者可以自己动手试验一下。</p>
<p>这一节的内容到此结束。到目前为止内容还比较简单，下一节的内容才是宏真正烧脑的地方。下节预告： object-like 宏的递归展开。</p>
<h3 id="附录：什么是-token"><a href="#附录：什么是-token" class="headerlink" title="附录：什么是 token"></a>附录：什么是 token</h3><p>什么是 token？token 在编译原理中只语法符号或者语法标记。可以看做是用来标记某个语法成分的抽象，一般由 token 名和一些属性组成。比如说数字 1 可以认为是一个整数常量，token 名为integer-constant，且其属性值为 1。对于宏来说共有这么几种：</p>
<ul>
<li>identifier 标识符，这个和 C 语言的标识符定义一致</li>
<li>pp-number 预处理数字，其实和 C 语言中的数字也是类似的，区别在于多了一种情况，就是某种数字开头后跟非数字标识符的情况，比如 12aa，1.2bc 这种</li>
<li>character-constant 字符常量，就是’a’, ‘\n’ 等</li>
<li>string-literal 字符串字面量 “hello world”</li>
<li>punctuator 标点符号 + - -&gt; &gt;&gt; 等</li>
<li>除了上边所列情况以外的所有非空白字符<br>例如下边这个宏中的替换列表 token 化以后就是 [identifier] [punctuator] [pp-number]</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo(x) x ## 12</span></span><br></pre></td></tr></table></figure>
<h2 id="object-like展开"><a href="#object-like展开" class="headerlink" title="object-like展开"></a>object-like展开</h2><p>这里是这个系列的第二篇。这次我们开始关注一些更复杂的宏特性————object-like 宏的递归展开。</p>
<h3 id="obj-like-的递归展开"><a href="#obj-like-的递归展开" class="headerlink" title="obj-like 的递归展开"></a>obj-like 的递归展开</h3><p>在替换列表中出现的宏会被展开，这一过程将递归的进行下去，且是深度优先的。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo foz bar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bar 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foz baz</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> baz 1</span></span><br><span class="line">foo</span><br><span class="line">-&gt; foz bar</span><br><span class="line">-&gt; baz bar</span><br><span class="line">-&gt; <span class="number">1</span> bar</span><br><span class="line">-&gt; <span class="number">1</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当一个宏完全展开后，下一个宏才会被展开。但是，如果只有这一条规则那么很容易出现无限递归的情况。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo bar</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bar foo</span></span><br><span class="line">foo</span><br><span class="line">-&gt; bar</span><br><span class="line">-&gt; foo</span><br><span class="line">-&gt; 无限循环</span><br></pre></td></tr></table></figure>
<p>因此在标准中对宏中涉及自指的部分做了限制：</p>
<blockquote>
<p>If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file’s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced.</p>
<p>16.3.4 cpp.recanISO n3690</p>
</blockquote>
<p>从字面含义理解很简单，主要表达了两点：</p>
<ol>
<li>在展开的过程中，如果替换列表中出现了被展开宏，那么该被展开宏不会被展开。</li>
<li>更进一步的，在展开的过程中，任何嵌套的展开过程中出现了被展开宏，该被展开宏也不会被展开。</li>
</ol>
<p>听起来很绕不是么，这属于典型的，说起来绕但是实现起来简单。没关系，我们可以这样理解。每次展开的时候会创建一个「蓝色集合」（一般将标记过的 token 称作 painted-blue），这个蓝色集合由本次展开的父级展开的蓝色集合加上当前展开的宏组成。然后每次对替换列表进行扫描的时候，所有在当前蓝色集合中的宏都不会被展开。挺起来还是很绕的话，我们来看一个实际展开的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> foo foo a bar b bar baz c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bar foo 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> baz bar 13</span></span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<p>定义三个宏 foo, bar, baz，展开过程如下图所示：</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="hz 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="hz 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/宏/" rel="tag"># 宏</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/10/用C进行面向对象编程/" rel="next" title="用C进行面向对象编程">
                <i class="fa fa-chevron-left"></i> 用C进行面向对象编程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/07/说说MVC，MVP和MVVM/" rel="prev" title="说说MVC，MVP和MVVM">
                说说MVC，MVP和MVVM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="hz" />
            
              <p class="site-author-name" itemprop="name">hz</p>
              <p class="site-description motion-element" itemprop="description">coding life</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/bjut-hz" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础概念"><span class="nav-number">1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#楔子"><span class="nav-number">1.1.</span> <span class="nav-text">楔子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏的定义"><span class="nav-number">1.2.</span> <span class="nav-text">宏的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#宏的操作符"><span class="nav-number">1.3.</span> <span class="nav-text">宏的操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串化操作符"><span class="nav-number">1.4.</span> <span class="nav-text">字符串化操作符 #</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Token-粘贴操作符"><span class="nav-number">1.5.</span> <span class="nav-text">Token 粘贴操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附录：什么是-token"><span class="nav-number">1.6.</span> <span class="nav-text">附录：什么是 token</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object-like展开"><span class="nav-number">2.</span> <span class="nav-text">object-like展开</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#obj-like-的递归展开"><span class="nav-number">2.1.</span> <span class="nav-text">obj-like 的递归展开</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://hezhenzhensite.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/01/25/宏定义黑魔法-从入门到奇技淫巧/';
          this.page.identifier = '2018/01/25/宏定义黑魔法-从入门到奇技淫巧/';
          this.page.title = '宏定义黑魔法-从入门到奇技淫巧';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://hezhenzhensite.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
